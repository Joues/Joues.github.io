<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/06/hello-world/"/>
      <url>/2020/06/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令（必备）</title>
      <link href="/2020/05/29/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E5%BF%85%E5%A4%87%EF%BC%89/"/>
      <url>/2020/05/29/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E5%BF%85%E5%A4%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Git常用命令（必备） Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库</p><a id="more"></a><h3 id="Git常用命令（必备）"><a href="#Git常用命令（必备）" class="headerlink" title="Git常用命令（必备）"></a>Git常用命令（必备）</h3><p><img src="Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E5%BF%85%E5%A4%87%EF%BC%89%5Bhttp://yihangjou.gitee.io/images_ben/images/20200605/git.png%5D(http://yihangjou.gitee.io/images_ben/images/20200605/git.png)" alt="image-20200527110341996"></p><blockquote><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul></blockquote><h4 id="1-新建代码库"><a href="#1-新建代码库" class="headerlink" title="1.新建代码库"></a>1.新建代码库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h4 id="3-增加-删除文件"><a href="#3-增加-删除文件" class="headerlink" title="3.增加/删除文件"></a>3.增加/删除文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h4 id="4-代码提交"><a href="#4-代码提交" class="headerlink" title="4.代码提交"></a>4.代码提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h4 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure><h4 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h4 id="7-查看信息"><a href="#7-查看信息" class="headerlink" title="7.查看信息"></a>7.查看信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h4 id="8-远程同步"><a href="#8-远程同步" class="headerlink" title="8.远程同步"></a>8.远程同步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h4 id="9-撤销"><a href="#9-撤销" class="headerlink" title="9.撤销"></a>9.撤销</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h4 id="10-其他"><a href="#10-其他" class="headerlink" title="10.其他"></a>10.其他</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JSP</title>
      <link href="/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91JSP/"/>
      <url>/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91JSP/</url>
      
        <content type="html"><![CDATA[<p>JSP  1. 建立JSP JSP最终会变成一个完整的servlet在Web容器中运行。</p><a id="more"></a><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="1-建立JSP"><a href="#1-建立JSP" class="headerlink" title="1. 建立JSP"></a>1. 建立JSP</h2><ul><li>JSP最终会变成一个完整的servlet在Web容器中运行。</li><li>scriptlet就是放在&lt;% … %&gt;标记中的Java代码。</li><li>scriptelet代码会放在生成的servlet的服务方法中。</li><li>指令有3中：page、include、taglib</li></ul><h2 id="2-page指令"><a href="#2-page指令" class="headerlink" title="2. page指令"></a>2. page指令</h2><ul><li>导入单个包：<pre><code>&lt;% @ page import=&quot;...&quot; %&gt;</code></pre></li><li>导 入多个包，用逗号分离多个包。</li><li>Java代码放在带百分号的尖括号中间，指令会为元素开始记号再增加一个字符@。</li><li>page指令的属性：<ul><li>import</li><li>isThreadSafe</li><li>contentType：定义JSP响应的MIME内容。</li><li>isElIgnored：定义转化页面时是否忽略EL表达式。</li><li>isErrorPage：定义当前页面是否是另一个JSP的错误页面，默认false，不能使用隐式的exception对象。</li><li>errorPage：定义一个资源的URL</li><li>language：定义scriptlet、表达式和声明中使用的脚本语言。现在可取值只有java。</li><li>extends；JSP变成servlet类后集成的类</li><li>session：定义页面是否有隐式的session对象，默认true。</li><li>buffer：定义隐式out对象如何处理缓存。</li><li>autoFlush：定义缓存的输出是否自动刷新输出，默认是true。</li><li>info：定义放到转换后页面中的串，这样能使用所生成servlet继承的getServletInfo()方法来得到这个信息。</li><li>pageEncoding：定义编码。</li></ul></li></ul><h2 id="3-表达式"><a href="#3-表达式" class="headerlink" title="3. 表达式"></a>3. 表达式</h2><ul><li>表达式会为元素的开始记号增加一个字符：=。</li><li>表达式最后没有分号。</li><li>所有scriptlet中声明的变量总是局部变量。</li></ul><h2 id="4-JSP声明"><a href="#4-JSP声明" class="headerlink" title="4. JSP声明"></a>4. JSP声明</h2><ul><li>JSP声明用于声明所生成servlet类的成员，变量和方法都可以声明。</li><li>JSP声明会为元素的开始记号增加一个字符：！</li><li>JSP声明的所有内容都会增加到类中，并且置于服务方法之外。</li><li>可以声明静态变量和方法。</li></ul><h2 id="5-JSP隐式对象"><a href="#5-JSP隐式对象" class="headerlink" title="5. JSP隐式对象"></a>5. JSP隐式对象</h2><ul><li>out——JspWriter</li><li>request</li><li>response</li><li>session</li><li>application——ServletContext</li><li>config——ServletConfig</li><li>exception(只有指定的错误页面才能用这个隐式对象）</li><li>pageContext——PageContext</li><li>page——Object</li><li>可以覆盖jspInit方法。</li><li>可以在配置文件中配置jsp初始化参数。</li></ul><h2 id="6-JSP中的属性"><a href="#6-JSP中的属性" class="headerlink" title="6. JSP中的属性"></a>6. JSP中的属性</h2><ul><li>JSP会使用4个隐式对象之一来得到和设置对应JSP中4个属性作用域的属性：<ul><li>应用：application</li><li>请求：request</li><li>会话：session</li><li>页面：pageContext</li></ul></li><li>可以使用PageContext引用来得到任意作用域的属性。</li><li>PageContext类中保存着作用域常量。</li><li>findAttribute方法用来查找一个属性。</li><li>findAttribute会现在页面上下文查找，如果没有，就会先在请求作用域查找，再查找会话作用域，最后查找应用作用域，找到就截止。</li></ul><h2 id="7-taglib指令"><a href="#7-taglib指令" class="headerlink" title="7. taglib指令"></a>7. taglib指令</h2><ul><li>定义JSP可以使用的标记库。</li></ul><h2 id="8-include指令"><a href="#8-include指令" class="headerlink" title="8. include指令"></a>8. include指令</h2><ul><li>定义在转换时增加到当前页面的文本和代码。用来增加重复使用的代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Servlet、Jsp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>会话状态</title>
      <link href="/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81/"/>
      <url>/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>会话状态  会话管理  HttpSession对象可以保存跨同一个客户多个请求的会话状态。</p><a id="more"></a><h1 id="会话状态"><a href="#会话状态" class="headerlink" title="会话状态"></a>会话状态</h1><h2 id="1-会话管理"><a href="#1-会话管理" class="headerlink" title="1. 会话管理"></a>1. 会话管理</h2><ul><li>HttpSession对象可以保存跨同一个客户多个请求的会话状态。</li><li>HTTP协议使用的是无状态连接，客户浏览器与服务器建立连接，发出请求，得到响应，然后关闭连接。连接只为一个请求/响应存在。</li><li>对容器而言，每个请求都来自与一个新的客户。</li><li>如果用户登录，而且连接是安全的(HTTPS)，容器就能准确的知道是哪一个客户，但是条件太苛刻，一般不满足。</li><li>客户需要一个唯一的会话ID。</li><li>容器和客户通过cookie交换会话ID信息。</li><li>Set-Cooke和Cookie只是响应和请求中发送的另一个首部。</li><li>容器会做cookie的所有工作。</li><li>isNew方法可以判断会话是否是新的。</li><li>也可以通过与会话相关的事件监听器得到一个会话。</li><li>如果不想要一个新会话，可以使用getSession(false)方法。</li></ul><h2 id="2-URL重写"><a href="#2-URL重写" class="headerlink" title="2. URL重写"></a>2. URL重写</h2><ul><li>当客户不接受cookie时，使用URL重写来传递会话ID。</li><li>禁用cookie的客户会忽略Set-Cookie响应首部。</li><li>容器默认先使用cookie，如果使用cookie失败才会使用URL重写。</li><li>当想把请求重定向到另外一个URL但还想使用一个会话时，可以使用response.encodeRedirectURL()方法。</li><li>URL编码只和响应有关，只能在HttpServletResponse对象上调用。</li></ul><h2 id="3-删除回话"><a href="#3-删除回话" class="headerlink" title="3. 删除回话"></a>3. 删除回话</h2><ul><li>会话对象占用着资源，不应该过久地保留。</li><li>HttpSession接口的方法：<ul><li>getCreationTime()返回第一次创建会话的时间。</li><li>getLastAccessedTime()返回容器最后一次得到包含这个会话ID的请求后，过去多少时间（毫秒）。</li><li>setMaxInactiveInterval()指定对于这个会话客户请求的最大间隔时间。</li><li>getMaxInactiveInterval()返回对于这个会话客户请求的最大时间间隔。</li><li>invalidate()结束回话，当前存储在这个会话中的所有属性也会解除绑定。</li></ul></li><li>会话有3种死法：<ul><li>超时</li><li>在会话对象上调用invalidate()</li><li>应用结束</li></ul></li><li>可以在配置文件中配置会话超时。<pre><code>&lt;session-config&gt;    &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt;</code></pre></li><li>配置的单位是分钟。</li><li>使用session.setMaxInactiveInterval()单位是秒。</li><li>会话的超时时间设置为-1时，永远不到期。</li></ul><h2 id="4-定制cookie"><a href="#4-定制cookie" class="headerlink" title="4. 定制cookie"></a>4. 定制cookie</h2><ul><li>cookie实际就是在客户和服务器之间交换的一小段数据。</li><li>cookie默认与会话的寿命一样长。可以让cookie活的更长一些</li><li>使用cookie.setMaxAge()定义生命长度，秒为单位。设为-1时，浏览器退出cookie就消失。</li><li>使用response.addCookie()方法把cookie发给客户。</li><li>使用request.getCookies()得到请求的cookie数组。</li><li>cookie和首部不同，响应增加首部时，要把名和值String作为参数传入，响应增加Cookie时，要传递一个Cookie对象。</li><li>cookie没有setCookie方法。</li></ul><h2 id="5-会话生命周期事件"><a href="#5-会话生命周期事件" class="headerlink" title="5. 会话生命周期事件"></a>5. 会话生命周期事件</h2><ul><li>生命周期<ul><li>创建会话</li><li>撤销会话</li><li>监听者类型：HttpSessionListener</li></ul></li><li>属性<ul><li>增加一个属性：setAttribute()。</li><li>删除一个属性；removeAttribute()。</li><li>替换一个属性：setAttribute()。</li><li>监听者类型：HttpSessionAttributeListener</li></ul></li><li>迁移<ul><li>会话准备钝化：在会话移动之前调用。</li><li>会话已经激活：容器已经把会话迁移到另一个VM中。在应用的其他部分调用getAttribute()之前调用。</li><li>监听者类型：HttpSessionActivationListener</li></ul></li><li>HttpSessionBindingListener对应会话属性一生中的关键时刻。</li><li>会话绑定监听者不在配置文件中配置。</li></ul><h2 id="6-会话迁移"><a href="#6-会话迁移" class="headerlink" title="6. 会话迁移"></a>6. 会话迁移</h2><ul><li>只有HttpSession对象及其属性会从一个VM移动到另一个VM。</li><li>每个VM有一个ServletContext，每个VM的每个servlet有一个ServletConfig。</li><li>只有一个HttpSession对象，不论应用分布在多少个VM上。</li><li>非串行化属性需要让其属性对象类实现HttpSessionActivationListener，并使用激活/钝化回调方法解决这个问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Servlet、Jsp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>属性和监听者</title>
      <link href="/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%91%E5%90%AC%E8%80%85/"/>
      <url>/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%91%E5%90%AC%E8%80%85/</url>
      
        <content type="html"><![CDATA[<p>属性和监听者 1. servlet初始化参数 可以在配置文件中给一个servlet配置初始化参数。 在servlet代码中调用getServletConfig().getInitParameter()获取。</p><a id="more"></a><h1 id="属性和监听者"><a href="#属性和监听者" class="headerlink" title="属性和监听者"></a>属性和监听者</h1><h2 id="1-servlet初始化参数"><a href="#1-servlet初始化参数" class="headerlink" title="1. servlet初始化参数"></a>1. servlet初始化参数</h2><ul><li>可以在配置文件中给一个servlet配置初始化参数。</li><li>在servlet代码中调用getServletConfig().getInitParameter()获取。</li><li>在servlet初始化之前不能使用servlet初始化参数。</li><li>servlet初始化参数只能在容器初始化servlet时读一次。</li></ul><h2 id="2-上下文初始化参数"><a href="#2-上下文初始化参数" class="headerlink" title="2. 上下文初始化参数"></a>2. 上下文初始化参数</h2><ul><li>上下文初始化参数对整个Web应用都可用。</li><li>在servlet代码中调用getServletContext().getInitParameter()获取。</li><li>每一个servlet有一个ServletConfig。</li><li>每一个Web应用有一个ServletContext。</li><li>如果应用是分布式的，每个JVM有一个ServletContext。</li><li>ServletConfig对象拥有该servlet的ServletContext的引用。</li></ul><h2 id="3-监听者类"><a href="#3-监听者类" class="headerlink" title="3. 监听者类"></a>3. 监听者类</h2><ul><li>监听ServletContext的初始化和撤销事件，这个类实现了ServletContextListener。</li><li>不只面向上下文事件，还可以监听与上下文属性、servlet请求和属性，以及HTTP会话和会话属性相关的事件。</li><li>8个监听者；<ul><li>ServletContextAttributeListener</li><li>HttpSessionListener</li><li>ServletRequestListener</li><li>ServletRequestAttributeListener</li><li>HttpSessionBindingListener</li><li>HttpSessionAttributeListener</li><li>ServletContextListener</li><li>HttpSessionActivationListener</li></ul></li><li>HttpSessionAttributeListener，当会话中增加、删除、或替换了某种类型的属性时能知道。</li><li>HttpSessionBindingListener，属性本身能够在增加到一个会话或者从会话删除时或的通知。</li><li>容器会通过注册监听者的顺序进行通知。</li></ul><h2 id="４-属性"><a href="#４-属性" class="headerlink" title="４. 属性"></a>４. 属性</h2><ul><li>属性就像是钉到公告栏上的一个对象。</li><li>三个作用域；上下文，请求和会话。</li><li>分别由ServletContext，ServletRequest和HttpSession接口处理。</li><li>上下文作用域不是线程安全的！</li><li>同步服务方法并不能保护上下文属性。</li><li>同步服务方法只能不让同一servlet的新请求访问上下文属性，但是无法杜绝其他servet访问。</li><li>需要对上下文加锁，而不是对servlet加锁。<pre><code>synchronized(getServletContext()){ ... }</code></pre></li><li>会话属性同样是线程不安全的，一个会话有可能由多个请求（新的浏览器窗口）。</li><li>对会话属性也采用上锁的方法，对HttpSession对象同步。<pre><code>synchronized(session){ ... }</code></pre></li><li>同步代码会导致大量的开销，也会妨碍并发性。</li><li>只有请求属性和局部变量是线程安全的。</li></ul><h2 id="5-请求属性和请求分派"><a href="#5-请求属性和请求分派" class="headerlink" title="5. 请求属性和请求分派"></a>5. 请求属性和请求分派</h2><ul><li>如果希望应用的其他组件接管全部或部分请求，就可以使用请求属性。</li><li>RequestDispatcher可以让组件的其他部分接管请求。</li><li>RequestDispatcher只有两个方法：forward()和include()。</li><li>可以通过ServletRequest得到RequestDispatcher，参数是相对路径。</li><li>可以通过ServletContext得到RequestDispatcher，参数必须使用斜线。</li><li>如果已经提交了响应，就不能再转发请求！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Servlet、Jsp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>请求和响应</title>
      <link href="/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"/>
      <url>/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<p>请求和响应 1. servlet的生命周期  如果servlet没有初始化，则要么正在初始化，正在撤销，要么就是不存在。</p><a id="more"></a><h1 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h1><h2 id="1-servlet的生命周期"><a href="#1-servlet的生命周期" class="headerlink" title="1. servlet的生命周期"></a>1. servlet的生命周期</h2><ul><li><p>如果servlet没有初始化，则要么正在初始化，正在撤销，要么就是不存在。</p><ul><li>Web容器加载servlet类。</li><li>初始化servlet（构造函数运行）</li><li>init() (在servlet一生中只调用一次，而且必须在容器调用service()之前完成)</li><li>service() (servlet一生主要都在这里度过，用于处理客户请求)</li><li>destroy() （在servlet被垃圾回收之前有机会清理资源，与init()一样，destroy()也只能调用一次)</li></ul></li><li><p>构造函数使servlet类成为对象。</p></li><li><p>init方法在servlet实例创建后，在service方法之前调用。</p></li><li><p>service方法在第一个客户请求到来时，容器会开始一个新线程，或者从线程池分配一个线程。</p></li><li><p>doGet和doPost方法：service方法根据请求的HTTP方法调用。</p></li><li><p>每个请求都在一个单独的线程中运行。</p></li><li><p>容器运行多个线程来处理一个servlet的多个请求。</p></li><li><p>每个客户请求都会生成一对新的请求和响应对象。</p></li><li><p>在调用构造函数和init方法之间，servlet处在一种薛定谔servlet状态。</p><blockquote><p>薛定谔状态：既没有完全死，也不完全活，介于二者之间的一个状态。</p></blockquote></li><li><p>每个servlet都有一个ServletConfig对象。</p><ul><li>用于向servlet传递部署时信息。</li><li>用于访问ServletContext</li><li>参数在部署描述文件中配置。</li></ul></li><li><p>每个web应用只有一个ServletContext。</p></li></ul><h2 id="2-GET和POST"><a href="#2-GET和POST" class="headerlink" title="2. GET和POST"></a>2. GET和POST</h2><ul><li>除了GET和POST外，Http方法还有HEAD、TRACE、OPTIONS、PUT、DELETE、CONNECT方法。</li><li>HttpServlet中没有doConnect方法，其他都有。</li><li>Get参数数据只能是放在请求行的内容，对参数数据有限制。</li><li>POST有一个消息体，存放参数数据。</li><li>GET不会对服务器做出任何改变，只用来获取某些东西。</li><li>POST用于发送数据进行处理。</li></ul><h2 id="3-幂等"><a href="#3-幂等" class="headerlink" title="3. 幂等"></a>3. 幂等</h2><ul><li>幂等：反复做同一件事，不会有预料不到的副作用。</li><li>GET、HEAD、PUT是幂等的。</li><li>POST不是幂等的。</li><li>默认是GET请求。</li></ul><h2 id="4-请求方法"><a href="#4-请求方法" class="headerlink" title="4. 请求方法"></a>4. 请求方法</h2><ul><li>getHeader方法获得客户平台和浏览器信息。</li><li>getCookies方法获得与请求相关的cookie。</li><li>getSession方法获得与客户相关的会话。</li><li>getMethod方法获得请求的HTTP方法。</li><li>getInputStream方法获得请求输入流。</li><li>getRemotePort方法指得到客户的端口。</li><li>对于一个servlet，远程意味着客户。</li><li>getLocalPort方法指请求最后发送到哪个端口。</li><li>getServerPort方法指请求原来发送到哪个端口。</li></ul><h2 id="5-响应方法"><a href="#5-响应方法" class="headerlink" title="5. 响应方法"></a>5. 响应方法</h2><ul><li>setContextType方法设置MIME类型。</li><li>setContextType方法可以告诉浏览器发回东西的类型，可能需要启动一个辅助应用。</li><li>常见的MIME类型：<ul><li>text/html</li><li>application/pdf</li><li>video/quicktime</li><li>application/java</li><li>image/jpeg</li><li>application/jar</li><li>application/octet-stream</li><li>application/x-zip</li></ul></li><li>getWriter获得字符输出流。</li><li>getOutputStream获得字节输出流。</li></ul><h2 id="6-字节和字符输出流"><a href="#6-字节和字符输出流" class="headerlink" title="6. 字节和字符输出流"></a>6. 字节和字符输出流</h2><ul><li>PrintWriter用于输出字符数据。</li><li>ServletOutputStream用于输出字节。</li><li>println写至PrintWriter。</li><li>write挟制ServletOutputStream。</li></ul><h2 id="7-增加和设置响应首部"><a href="#7-增加和设置响应首部" class="headerlink" title="7. 增加和设置响应首部"></a>7. 增加和设置响应首部</h2><ul><li>setHeader方法：如果响应中已经有同名的首部，则用这个值替换原来的值，否则增加一个新首部和值。</li><li>addHeader方法：为响应新增加一个首部和值，或者向现有的首部增加一个值。</li><li>setIntHeader方法：用提供的整数值替换现有首部的值，或者向响应增加一个新首部和值。</li><li>如果相应中没有首部，setHeader和addHeader会增加一个首部和相应的值。</li><li>如果已经有首部，setHeader会覆盖现有的值，addHeader将增加一个值。</li></ul><h2 id="8-重定向和转发"><a href="#8-重定向和转发" class="headerlink" title="8. 重定向和转发"></a>8. 重定向和转发</h2><h3 id="1-重定向"><a href="#1-重定向" class="headerlink" title="1. 重定向"></a>1. 重定向</h3><ul><li>请求重定向让客户完成工作。</li><li>servlet调用sendRedirect方法重定向。</li><li>不能在写到响应之后再调用sendRedirect()。</li><li>在servlet中应该明确，要么处理请求，要么调用sendRedirect()让别人处理请求。</li><li>sendRedirect()取一个String，不是URL对象。</li><li>用户会在地址栏看到新的URL。</li></ul><h3 id="2-转发"><a href="#2-转发" class="headerlink" title="2. 转发"></a>2. 转发</h3><ul><li>请求转发在服务器端工作。</li><li>浏览器地址栏URL没有变化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Servlet、Jsp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无脚本的JSP</title>
      <link href="/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E6%97%A0%E8%84%9A%E6%9C%AC%E7%9A%84JSP/"/>
      <url>/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E6%97%A0%E8%84%9A%E6%9C%AC%E7%9A%84JSP/</url>
      
        <content type="html"><![CDATA[<p>无脚本的JSP 1. JavaBean标准动作 1. <code>&lt;jsp:useBean&gt;</code>和<code>&lt;jsp:getProperty&gt;</code></p><a id="more"></a><h1 id="无脚本的JSP"><a href="#无脚本的JSP" class="headerlink" title="无脚本的JSP"></a>无脚本的JSP</h1><h2 id="1-JavaBean标准动作"><a href="#1-JavaBean标准动作" class="headerlink" title="1. JavaBean标准动作"></a>1. JavaBean标准动作</h2><h3 id="1-lt-jsp-useBean-gt-和-lt-jsp-getProperty-gt"><a href="#1-lt-jsp-useBean-gt-和-lt-jsp-getProperty-gt" class="headerlink" title="1. &lt;jsp:useBean&gt;和&lt;jsp:getProperty&gt;"></a>1. <code>&lt;jsp:useBean&gt;</code>和<code>&lt;jsp:getProperty&gt;</code></h3><ul><li><code>&lt;jsp:useBean&gt;</code>标签用来声明和初始化在<code>&lt;jsp:getProperty&gt;</code>标签中使用的具体的bean对象。</li><li><code>&lt;jsp:useBean&gt;</code>声明初始化一个bean属性时，要声明id，class，scope。</li><li><code>&lt;jsp:getProperty&gt;</code>得到bean属性时，要有name和property属性值。</li><li><code>&lt;jsp:useBean&gt;</code>还可以创建一个bean。</li><li>可以使用<code>&lt;jsp:setProperty&gt;</code>设置一个属性值。</li><li><code>&lt;jsp:useBean&gt;</code>可以有体，可以把设置方法放在体内。</li><li>体中的代码会有条件的运行，只有找不到bean而且创建一个新bean时才会执行。</li><li>type属性可以是class类型，抽象类型或者借口，只要能作为bean对象class类型的声明引用类型。class必须时type的一个子类或者具体实现。</li><li>如果使用type，没有class，bean必须已经存在。</li><li>如果使用了class，class不能是抽象类，而且必须有一个无参数的构造函数。</li><li>scope默认属性为page。</li><li>type == 引用类型（可以抽象）</li><li>class == 对象类型（必须具体）</li><li>脚本可以放在标准动作内部。</li></ul><h3 id="2-性质和请求参数"><a href="#2-性质和请求参数" class="headerlink" title="2. 性质和请求参数"></a>2. 性质和请求参数</h3><ul><li>param属性可以把bean的性质值设置为一个请求参数的值。</li><li>如果请求参数名与bean性质名匹配，就不需要在<code>&lt;jsp:setProperty&gt;</code>标记中为该性质指定值。</li><li>如果所有请求参数名与bean性质名匹配，可以把property设置为<code>*</code>自动匹配所有性质。</li><li>Bean标记会自动转换String或基本类型的性质。</li><li>使用脚本时不会完成自动转换。</li></ul><h2 id="2-EL表达式"><a href="#2-EL表达式" class="headerlink" title="2. EL表达式"></a>2. EL表达式</h2><ul><li>打印嵌套性质使用EL表达式非常容易。</li><li>EL表达式总是放在大括号里，而且前面有一个美元符前缀：<code>${...}</code></li><li>表达式的第一个命名变量可以使一个隐式对象，也可以是一个属性。</li></ul><h3 id="1-点号操作符"><a href="#1-点号操作符" class="headerlink" title="1. 点号操作符"></a>1. 点号操作符</h3><ul><li>如果表达式中变量后面有一个点号，点号左边的变量必须是一个Map或bean。</li><li>点号右边必须是一个Map键或一个bean的属性。</li><li>除pageContext隐式对象是一个bean，其他都是Map。</li><li>如果不能用作为Java代码中的变量名，就不能放在点号后面。</li></ul><h3 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2. []操作符"></a>2. []操作符</h3><ul><li>使用[]时，左边可以是List或数组，右边可以是一个数，或者解析为一个数。</li><li>中括号里可以是Map键，可以是bean性质，也可以是数组或list的索引。</li><li>数组和List中的String索引会强制转换为int</li><li>对于bean和Map，这两个操作符都可以用。</li><li>如果中括号中不是String直接量，就会计算。</li><li>在中括号中可以使用嵌套表达式。</li></ul><h3 id="3-EL隐式对象"><a href="#3-EL隐式对象" class="headerlink" title="3. EL隐式对象"></a>3. EL隐式对象</h3><ul><li>pageScope</li><li>requestScope</li><li>sessionScope</li><li>applicationScope</li><li>param</li><li>paramValues</li><li>header</li><li>headerValues</li><li>cookie</li><li>initParam</li><li>pageContext</li><li>使用requestScope对象，可以把属性名放在引号中。</li></ul><h2 id="3-EL函数"><a href="#3-EL函数" class="headerlink" title="3.EL函数"></a>3.EL函数</h2><ul><li>函数方法必须是公共、静态的。</li><li>需要编写标记库描述文件（TLD）。</li><li>在JSP中放一个taglib指令。</li><li>taglib指令中的uri要和配置文件中的uri匹配。</li><li>EL能友好地处理null，算术表达式中看做0，逻辑表达式中看做false。</li></ul><h2 id="4-布局模板"><a href="#4-布局模板" class="headerlink" title="4. 布局模板"></a>4. 布局模板</h2><h3 id="1-include指令"><a href="#1-include指令" class="headerlink" title="1. include指令"></a>1. include指令</h3><ul><li><code>&lt;%@ include file=&quot;***&quot; %&gt;</code></li></ul><h3 id="2-lt-jsp-include-gt-标准动作"><a href="#2-lt-jsp-include-gt-标准动作" class="headerlink" title="2. &lt;jsp:include&gt;标准动作"></a>2. <code>&lt;jsp:include&gt;</code>标准动作</h3><ul><li><code>&lt;jsp:include page=&quot;***&quot;</code>/&gt;</li><li>内部原理并不相同。include指令在转换时发生。标准动作在运行时发生。</li><li>include指令相当于把目标JSP内容复制到本JSP中。</li><li>include标准动作会在运行时插入目标JSP的响应。</li></ul><h2 id="5-使用-lt-jsp-param-gt-定制包含的内容"><a href="#5-使用-lt-jsp-param-gt-定制包含的内容" class="headerlink" title="5. 使用&lt;jsp:param&gt;定制包含的内容"></a>5. 使用<code>&lt;jsp:param&gt;</code>定制包含的内容</h2><ul><li>在include标准动作中使用<code>&lt;jsp:param&gt;</code></li></ul><h2 id="6-lt-jsp-forward-gt-标准动作"><a href="#6-lt-jsp-forward-gt-标准动作" class="headerlink" title="6. &lt;jsp:forward&gt;标准动作"></a>6. <code>&lt;jsp:forward&gt;</code>标准动作</h2><ul><li>可以从一个JSP转发到另一个JSP，或者从一个JSP转发到一个servlet，还可以从一个JSP转发到Web应用中的任何其他资源。</li><li>尽量少使用，视图就是视图，控制逻辑交给控制层。</li><li>发生转发时，请求转发到的目标资源首先会清空响应缓存区。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Servlet、Jsp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0. Spring项目搭建</title>
      <link href="/2020/02/20/Spring/%E3%80%90Spring%E3%80%910.%20Spring%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/02/20/Spring/%E3%80%90Spring%E3%80%910.%20Spring%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>第一次使用idea搭建Spring项目的小伙伴可能都会碰到各种的问题，而我自己也是碰到各种问题，所以决定写个博客巩固下，方便以后使用，好了闲话就不多说了。</p><a id="more"></a><h2 id="0-Spring项目搭建"><a href="#0-Spring项目搭建" class="headerlink" title="0. Spring项目搭建"></a>0. Spring项目搭建</h2><p>​        第一次使用idea搭建Spring项目的小伙伴可能都会碰到各种的问题，而我自己也是碰到各种问题，所以决定写个博客巩固下，方便以后使用，好了闲话就不多说了。<br>​        首先得做个准备工作（电脑里得提前安装好idea和maven），项目所使用的jar包都是使用maven自动导入，所以没有下载安装maven的童鞋还得下载安装一个maven。</p><h3 id="0-0-前期准备"><a href="#0-0-前期准备" class="headerlink" title="0.0 前期准备"></a>0.0 前期准备</h3><p>​        打开Idea选择 File 》New 》Project… ，选择Maven，勾选Create from arcetype，找到org.apache.maven.archetype:maven-archetype-webapp 选中，点击Next按钮。<img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200216133646173.png" alt="image-20200216133646173"></p><p>pom.xml中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1. Spring的体系结构</title>
      <link href="/2020/02/20/Spring/%E3%80%90Spring%E3%80%911.%20Spring%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2020/02/20/Spring/%E3%80%90Spring%E3%80%911.%20Spring%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p> Spring是一个轻量级Java开发框架，最早由Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的偶合问题。它是一个分层的JavaSE/EE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p><a id="more"></a><h2 id="1-Spring的体系结构"><a href="#1-Spring的体系结构" class="headerlink" title="1. Spring的体系结构"></a>1. Spring的体系结构</h2><p>​        Spring是一个轻量级Java开发框架，最早由Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的偶合问题。它是一个分层的JavaSE/EE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p><h3 id="1-1-Spring的体系结构"><a href="#1-1-Spring的体系结构" class="headerlink" title="1.1 Spring的体系结构"></a>1.1 Spring的体系结构</h3><p>​        Spring框架至今已经集成了20多个模块，这些模块分布在核心容器（Core Container）、数据访问/集成（Data Access/Integration）层、Web层、AOP层（Aspect Oriented Programming，面向切面的编程）模块、植入（Instrumentation）模块、消息传播（Messaging）和测试（Test）模块中，如下图所示：</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191120213313974.png" alt="image-20191120213313974"></p><h4 id="1-1-1-核心容器"><a href="#1-1-1-核心容器" class="headerlink" title="1. 1.1 核心容器"></a>1. 1.1 核心容器</h4><ul><li>Spring-core模块：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IoC）和依赖注入（Dependency Injection，DI）功能。</li><li>Spring-beans模块：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象成为Bean。</li><li>Spring-context模块：建立在Core和Beans模块的基础之上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext接口是Context模块的焦点。</li><li>Spring-context-support模块：支持整合第三方库到Spring应用程序上下文，特别是用于高速缓存（EhCache、JCache）和任务调度（CommonJ、Quartz）的支持。</li><li>Spring-expression模块：提供了强大的表达式语言去支持运行时查询和操作对象图。这是JSP2.1规范中规定的同意表达式语言（Unified EL）的扩展。该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算数运算、变量命名以及从Spring的IoC容器中以名称检索对象。它还支持列表投影、选择以及常见的列表聚合。</li></ul><h4 id="1-1-2-AOP和Instrumentation"><a href="#1-1-2-AOP和Instrumentation" class="headerlink" title="1.1.2 AOP和Instrumentation"></a>1.1.2 AOP和Instrumentation</h4><ul><li>Spring-aop模块：提供了一个符合AOP要求的面向切面的编程实现，允许定义方法 拦截器和切入点，将代码按照功能进行分离，以便干净地解耦。</li><li>Spring-aspects模块：提供了与AspectJ的集成功能，AspectJ是一个功能强大且成熟的AOP框架。</li><li>Spring-instrument模块：提供了类植入（Instrumentation）支持和类加载器的实现，可以在特定的应用服务器中使用。</li></ul><h4 id="1-1-3-消息"><a href="#1-1-3-消息" class="headerlink" title="1.1.3 消息"></a>1.1.3 消息</h4><p>Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</p><h4 id="1-1-4-数据访问-集成"><a href="#1-1-4-数据访问-集成" class="headerlink" title="1.1.4  数据访问/集成"></a>1.1.4  数据访问/集成</h4><p>输入访问/集成层由JDBC、ORM、OXM、JMS和事务模块组成。</p><ul><li>Spring-jdbc模块：提供了一个JDBC的抽象层，消除了繁琐的JDBC编码和数据厂商特有的错误代码解析。</li><li>Spring-orm模块：为流行的对象关系映射（Object-Relational Mapping）API提供集成层，包括JPA和Hibernate。使用Spring-rom模块可以将这些O/R映射框架与Spring提供的所有其他功能结合使用，例如声明式事物管理功能。</li><li>Spring-oxm模块：提供了一个支持对象/XML映射的抽象层实现，例如JAXB、Castor、JiBX和XStream。</li><li>Spring-jms模块（Java Messaging Service）：指Java消息传递服务，包含用于生产和使用消息的功能。自Spring4.1以后，提供了Spring-messaging模块的集成。</li><li>Spring-tx模块（事物模块）：支持用于实现特殊接口和所有POJO（普通Java对象）类的编程和声明式事务管理。</li></ul><h4 id="1-1-5-Web"><a href="#1-1-5-Web" class="headerlink" title="1.1.5 Web"></a>1.1.5 Web</h4><p>Web层由Spring-Web、Spring-webmvc、Spring-websocket和Portlet模块组成。</p><ul><li>Spring-web模块：提供了基本的Web开发集成功能，例如多文件上传功能、使用Servlet监听器初始化一个IoC容器以及Web应用上下文。</li><li>Spring-webmvc模块：也称为Web-Servlet模块，包含用于Web应用程序的Spring MVC和REST Web Services实现。Spring MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与Spring Frameword的所有其他功能集成。</li><li>Spring-websocket模块：Spring 4.0 以后新增的模块，它提供了WebSocket和SockJS的实现。</li><li>Portlet模块：类似于Servlet模块的功能，提供了Portlet环境下的MVC实现。</li></ul><h4 id="1-1-6-测试"><a href="#1-1-6-测试" class="headerlink" title="1.1.6 测试"></a>1.1.6 测试</h4><p>Spring-test模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</p><h3 id="1-2-Spring的目录结构"><a href="#1-2-Spring的目录结构" class="headerlink" title="1.2 Spring的目录结构"></a>1.2 Spring的目录结构</h3><h4 id="1-2-1-Spring的Jar包"><a href="#1-2-1-Spring的Jar包" class="headerlink" title="1.2.1 Spring的Jar包"></a>1.2.1 Spring的Jar包</h4><p>下载到的Spring framework ZIP文件解压缩后的目录结构如图所示：</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191120221947450.png" alt="image-20191120221947450"></p><ul><li><p>docs目录包含Spring的API文档和开发规范；</p></li><li><p>libs目录包含开发Spring应用所需要的Jar包和源代码；</p><blockquote><p>3类JAR文件：</p><ul><li>以RELEASE.jar结尾的文件是Spring框架class的JAR包，即开发Spring应用所需要的JAR包；</li><li>以RELEASE-javadoc.jar结尾的文件是Spring框架API文档的压缩包；</li><li>以RELEASE-sources.jar结尾的文件是Spring框架源文件的压缩包。</li></ul></blockquote><blockquote><p>4个基础包：</p><ol><li>spring-core-x.x.x.RELEASE.jar ——（Spring-core 模块）</li><li>spring-beans-x.x.x.RELEASE.jar —— （Spring-beans模块）</li><li>spring-context-x.x.x.RELEASE.jar —— （Spring-context模块）</li><li>spring-expression-x.x.x.RELEASE.jar —— （Spring-expression模块）</li></ol></blockquote></li><li><p>schema目录包含开发Spring应用所需要的schema文件，这些schema文件定义了Spring相关配置文件的约束。</p></li></ul><h4 id="1-2-2-commons-logging的JAR包"><a href="#1-2-2-commons-logging的JAR包" class="headerlink" title="1.2.2 commons.logging的JAR包"></a>1.2.2 commons.logging的JAR包</h4><p>​         Spring框架依赖于Apache Commons Logging组件，该组件的JAR包可以通过网址“<a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi”下载。" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-logging/download_logging.cgi”下载。</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jsp技术</title>
      <link href="/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91Jsp%E6%8A%80%E6%9C%AF/"/>
      <url>/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91Jsp%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>Jsp技术 Jsp 概述 Jsp：Java Server Page Jsp 程序是在传统的HTML文档中插入<strong>Java程序段或Jsp标签</strong>而形成。(*.jsp)Jsp技术</p><a id="more"></a><h2 id="Jsp技术"><a href="#Jsp技术" class="headerlink" title="Jsp技术"></a>Jsp技术</h2><h3 id="1-Jsp-概述"><a href="#1-Jsp-概述" class="headerlink" title="1. Jsp 概述"></a>1. Jsp 概述</h3><ul><li><p>Jsp：Java Server Page</p></li><li><p>Jsp 程序是在传统的HTML文档中插入<strong>Java程序段或Jsp标签</strong>而形成。(*.jsp)</p></li><li><p>Jsp 是一种实现静态和动态混合编码的技术。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> contentType=<span class="string">"text/html; charset=utf-8"</span>  pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">      &lt;%</span><br><span class="line">         Date d=<span class="keyword">new</span> Date();</span><br><span class="line">         <span class="keyword">int</span> h=d.getHours();</span><br><span class="line">         <span class="keyword">if</span>(h&gt;<span class="number">12</span>) out.print(<span class="string">"下午好"</span>);</span><br><span class="line">         <span class="keyword">else</span> out.print(<span class="string">"上午好"</span>);</span><br><span class="line">      %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;% <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123; %&gt;</span><br><span class="line">    &lt;!-- Jsp表达式 --&gt;</span><br><span class="line">&lt;div style="font-size:&lt;%=20+i%&gt;px"&gt;测试JSP&lt;/div&gt;</span><br><span class="line">     &lt;% &#125; %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="Jsp-执行过程"><a href="#Jsp-执行过程" class="headerlink" title="* Jsp 执行过程"></a>* Jsp 执行过程</h4><p>Jsp页面中的<strong>HTML标记(静态部分)交给客户端浏览器</strong>直接显示。</p><p><strong>服务器端执行&lt;%</strong>和<strong>%&gt;</strong>之间的Java程序(动态部分)，并把执行结果交给客户端的浏览器显示。 </p><p><strong>服务器端</strong>还要负责处理相关的<strong>Jsp标记</strong>，并将有关的处理结果发送到客户的浏览器。</p><h3 id="2-Jsp-脚本元素"><a href="#2-Jsp-脚本元素" class="headerlink" title="2. Jsp 脚本元素"></a>2. Jsp 脚本元素</h3><h4 id="2-1-HTML注释"><a href="#2-1-HTML注释" class="headerlink" title="2.1 HTML注释"></a>2.1 HTML注释</h4><p>  **<!-- 注释语句 --> **  客户端可见</p><h4 id="2-2-隐藏的注释"><a href="#2-2-隐藏的注释" class="headerlink" title="2.2 隐藏的注释"></a>2.2 隐藏的注释</h4><p><strong>&lt;%– 注释语句 –%&gt;</strong>  客户端不可见</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 张三编写   日期：  <span class="number">2016.3</span> --%&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="function">function <span class="title">clickme</span><span class="params">()</span></span>&#123;</span><br><span class="line">           alert(<span class="string">"你敢点我!"</span>);     <span class="comment">// js 注释</span></span><br><span class="line">       &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- 欢迎页面 --&gt;</span><br><span class="line">&lt;p onclick="clickme()" style="cursor: pointer"&gt;点击我&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="2-3-输出表达式"><a href="#2-3-输出表达式" class="headerlink" title="2.3 输出表达式"></a>2.3 输出表达式</h4><p> <strong>&lt;%= 表达式 %&gt;</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;% String s=<span class="string">"abcde"</span>; %&gt;</span><br><span class="line">字符串s= &lt;%=s%&gt;，长度= &lt;%= s.length()%&gt;</span><br></pre></td></tr></table></figure><h4 id="2-4-全局变量声明"><a href="#2-4-全局变量声明" class="headerlink" title="2.4 全局变量声明"></a>2.4 <strong>全局变量</strong>声明</h4><p><strong>&lt;%! 变量声明; [声明; ] … %&gt;</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;% i++;  %&gt;</span><br><span class="line">  &lt;p&gt;您是第&lt;%=i%&gt;个访问本站的客户&lt;/p&gt;</span><br><span class="line">  &lt;%! <span class="keyword">int</span> i=<span class="number">0</span>; %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="2-5-方法声明"><a href="#2-5-方法声明" class="headerlink" title="2.5 方法声明"></a>2.5 方法声明</h4><p> <strong>&lt;%! 方法代码 %&gt;</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;%! <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>  </span>&#123; </span><br><span class="line">              <span class="keyword">return</span> a+b; </span><br><span class="line">          &#125; </span><br><span class="line">   %&gt;</span><br><span class="line">  <span class="number">1</span>+<span class="number">2</span>=&lt;%= add(<span class="number">1</span>,<span class="number">2</span>) %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="2-6-类声明"><a href="#2-6-类声明" class="headerlink" title="2.6 类声明"></a>2.6 类声明</h4><p> <strong>&lt;%! 类代码 %&gt;</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%! <span class="class"><span class="keyword">class</span> <span class="title">GF</span> </span>&#123;</span><br><span class="line">          String XM;</span><br><span class="line">          <span class="keyword">int</span> AGE;</span><br><span class="line">          GF(String xm, <span class="keyword">int</span> a) &#123; XM=xm; AGE=a; &#125;</span><br><span class="line">          <span class="function">String <span class="title">getXM</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> XM;  &#125;</span><br><span class="line">             &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;%GF a=<span class="keyword">new</span> GF(<span class="string">"小明"</span>,<span class="number">20</span>);%&gt;</span><br><span class="line">    &lt;%=a.getXM() %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="3-Jsp动作组件"><a href="#3-Jsp动作组件" class="headerlink" title="3. Jsp动作组件"></a>3. Jsp动作组件</h3><ul><li><p>&lt; jsp:include&gt;：在<strong>页面中包含</strong>一个文件。</p></li><li><p>&lt; jsp:forward&gt;：把<strong>请求转发</strong>到另一个新的页面。</p></li><li><p>&lt; jsp:param&gt;：在<strong>动作组件中引入</strong>参数信息。</p></li><li><p>&lt; jsp:useBean&gt;：寻找或者实例化一个<strong>JavaBean</strong>。 【JavaBean中使用】</p></li><li><p>&lt; jsp:setProperty&gt;：设置<strong>JavaBean</strong>的属性。【JavaBean中使用】</p></li><li><p>&lt; jsp:getProperty&gt;：输出某个<strong>JavaBean</strong>的属性。【JavaBean中使用】</p></li></ul><h4 id="3-1-jsp-include"><a href="#3-1-jsp-include" class="headerlink" title="3.1 jsp:include"></a>3.1 <a href="jsp:include">jsp:include</a></h4><p>语法格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">"relativeURL"</span>/&gt;</span><br><span class="line">或</span><br><span class="line">&lt;jsp:include page=<span class="string">"relativeURL"</span>&gt; </span><br><span class="line">&lt;jsp:param name=<span class="string">"参数1"</span>  value=<span class="string">"参数1值"</span>/&gt;</span><br><span class="line">…</span><br><span class="line">&lt;jsp:param name=<span class="string">"参数n"</span>  value=<span class="string">"参数n值"</span>/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><h4 id="3-2-lt-jsp-forward-gt"><a href="#3-2-lt-jsp-forward-gt" class="headerlink" title="3.2 &lt; jsp:forward&gt;"></a>3.2 &lt; jsp:forward&gt;</h4><p>语法格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt; jsp:forward page=<span class="string">"relativeURL"</span>/&gt;</span><br><span class="line">或</span><br><span class="line">&lt; jsp:forward page=<span class="string">"relativeURL"</span>&gt; </span><br><span class="line">&lt;jsp:param name=“参数<span class="number">1</span>”  value=“参数<span class="number">1</span>值”/&gt;</span><br><span class="line">…</span><br><span class="line">&lt;jsp:param name=“参数n”  value=“参数n值”/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><h4 id="3-3-lt-jsp-param-gt"><a href="#3-3-lt-jsp-param-gt" class="headerlink" title="3.3 &lt; jsp:param&gt;"></a>3.3 &lt; jsp:param&gt;</h4><ul><li>用于<strong>传递参数</strong>信息，<strong>必须配合&lt; jsp:include&gt;或&lt; jsp:forward&gt;</strong>动作组件一起使用。</li></ul><p>语法格式：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:param name=“参数” value=“参数值”/&gt;</span><br></pre></td></tr></table></figure><h3 id="4-Jsp内置对象"><a href="#4-Jsp内置对象" class="headerlink" title="4. Jsp内置对象"></a>4. Jsp内置对象</h3><h4 id="4-1-request对象"><a href="#4-1-request对象" class="headerlink" title="4.1 request对象"></a>4.1 request对象</h4><ul><li><p>request对象中<strong>封装</strong>了客户端发送过来的所有的<strong>请求数据</strong>（包括请求头信息，请求方式，客户端ip地址以及请求参数等）。</p></li><li><p>request对象的<strong>作用域为一次请求</strong>。</p></li></ul><h4 id="4-2-response对象"><a href="#4-2-response对象" class="headerlink" title="4.2 response对象"></a>4.2 response对象</h4><ul><li>response对象代表服务器对客户端<strong>请求的响应</strong>。</li></ul><p>基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String name, String value)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String location)</span></span></span><br></pre></td></tr></table></figure><h5 id="4-2-1-response-setHeader-方法"><a href="#4-2-1-response-setHeader-方法" class="headerlink" title="4.2.1  response.setHeader()方法"></a>4.2.1  response.setHeader()方法</h5><ul><li><p>用法1：设置页面<strong>自动刷新</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"refresh"</span>, <span class="string">"秒数"</span>);</span><br></pre></td></tr></table></figure></li><li><p>用法2：设置<strong>定时跳转页面</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"refresh"</span>, <span class="string">"秒数 **;** URL=页面名称"</span>) ;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-2-2-response-sendRedirect-方法"><a href="#4-2-2-response-sendRedirect-方法" class="headerlink" title="4.2.2  response.sendRedirect()方法"></a>4.2.2  response.sendRedirect()方法</h5><ul><li><p>用法1：请求<strong>重定向</strong>到新页面（<strong>页面跳转</strong>）</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"http://www.wust.edu.cn"</span>);</span><br></pre></td></tr></table></figure></li><li><p>用法2：<strong>跳转时传递数据</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"edit.jsp?id=1"</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-2-3-redirect和forward方式区别"><a href="#4-2-3-redirect和forward方式区别" class="headerlink" title="4.2.3 redirect和forward方式区别"></a>4.2.3 redirect和forward方式区别</h5><table><thead><tr><th><strong>jsp:forward</strong></th><th><strong>response.sendRedirect**</strong>()**</th></tr></thead><tbody><tr><td>效率高，速度快</td><td>效率低，速度慢</td></tr><tr><td>地址栏不改变跳转，服务器端跳转，服务器之间内部转</td><td>地址栏改变跳转，客户端跳转（其中地址可以是任意的）</td></tr><tr><td>使用forward时，相同的request，依然能保留在下一个页面</td><td>客户端跳转，不同的request</td></tr><tr><td>传递参数：  &lt;jsp:param  name=” “ value=” “ /&gt;</td><td>URL传递参数：response.sendRedirect(“test.jsp?id=1234”)</td></tr><tr><td>无条件立刻跳转，之后的代码不再被执行</td><td>所有代码执行完毕之后再跳转</td></tr><tr><td>地址中的”/“代表网站地址，如:  <a href="http://localhost:8080/Test" target="_blank" rel="noopener">http://localhost:8080/Test</a></td><td>地址中的”/“代表服务器地址:  <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></td></tr></tbody></table><h4 id="4-3-session对象"><a href="#4-3-session对象" class="headerlink" title="4.3 session对象"></a>4.3 session对象</h4><ul><li><p>session代表服务器与客户端所建立的会话。</p><blockquote><p>从一个客户端打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。</p></blockquote></li><li><p>当一个客户首次访问服务器上页面时，服务器将产生一个session对象，同时分配一个String类型的id号。</p></li><li><p>session可以实现在一个会话期间的多页面间的数据共享/传递。</p></li></ul><h5 id="4-3-1-session基本用法"><a href="#4-3-1-session基本用法" class="headerlink" title="4.3.1 session基本用法"></a>4.3.1 <strong>session基本用法</strong></h5><ul><li><p>session.setAtrribute(String name, Object value)</p><blockquote><p>用value来初始化session对象某个属性(name指定)的值;</p><p>如果指定的属性不存在，则新建一个；如果已存在，则更改name属性的值。</p></blockquote></li><li><p>session.getAtrribute(String name)</p><blockquote><p>获得由name指定名称的session对象属性的值;</p><p>方法返回Object对象，因此，对返回的对象要用强制转换把得到的对象转换为此对象原来的类型;</p><p>如果属性不存在，返回空值。</p></blockquote></li></ul><h4 id="4-4-application对象"><a href="#4-4-application对象" class="headerlink" title="4.4 application对象"></a>4.4 application对象</h4><ul><li><p>Web服务器一旦启动，就会自动创建application对象，并一直保持，直到服务器关闭。</p></li><li><p>application对象负责提供应用程序在服务器中运行时的一些全局信息，客户端使用的application对象都是一样的。</p></li><li><p>在此期间，在任何地方对application对象相关属性的操作，都将影响到其他用户对此的访问。</p></li><li><p>application对象可以实现用户间数据的共享/传递。</p></li></ul><p>4.4.1 application基本用法</p><ul><li><p>application.setAttribute(String name, Object value)</p><blockquote><p>用value来初始化application对象某个属性(name指定)的值;</p><p>如果指定的属性不存在，则新建一个；如果已存在，则更改name属性的值。</p></blockquote></li><li><p>application.getAttribute(String name)</p><blockquote><p>获得由name指定名称的application对象属性的值;</p><p>方法返回Object对象，因此，对返回的对象要用强制转换把得到的对象转换为此对象原来的类型;</p><p>如果属性不存在，返回空值。</p></blockquote></li></ul><h4 id="4-5-out对象"><a href="#4-5-out对象" class="headerlink" title="4.5 out对象"></a>4.5 out对象</h4><ul><li><p>out对象用来向客户端发送数据(文本级)，其内容将是浏览器需要显示的内容。</p></li><li><p>常用方法：pirnt()</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Servlet、Jsp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4. Spring AOP</title>
      <link href="/2020/02/20/Spring/%E3%80%90Spring%E3%80%914.%20Spring%20AOP/"/>
      <url>/2020/02/20/Spring/%E3%80%90Spring%E3%80%914.%20Spring%20AOP/</url>
      
        <content type="html"><![CDATA[<p><strong>AOP ( Aspect-Oriented Programming ）</strong>即<strong>面向切面编程</strong>，它与<strong>OOP</strong> (Object-Oriented Programming ， <strong>面向对象</strong>编程） 相辅相成，提供了与OOP 不同的抽象软件结构的视角。</p><a id="more"></a><h2 id="4-Spring-AOP"><a href="#4-Spring-AOP" class="headerlink" title="4. Spring AOP"></a>4. Spring AOP</h2><h3 id="4-1-Spring-AOP的基本概念"><a href="#4-1-Spring-AOP的基本概念" class="headerlink" title="4.1 Spring AOP的基本概念"></a>4.1 Spring AOP的基本概念</h3><h4 id="4-1-1-AOP的概念"><a href="#4-1-1-AOP的概念" class="headerlink" title="4.1.1 AOP的概念"></a>4.1.1 AOP的概念</h4><p>​        <strong>AOP ( Aspect-Oriented Programming ）</strong>即<strong>面向切面编程</strong>，它与<strong>OOP</strong> (Object-Oriented Programming ， <strong>面向对象</strong>编程） 相辅相成，提供了与OOP 不同的抽象软件结构的视角。在OOP 中，以类作为程序的基本单元，而AOP 中的基本单元是Aspect （切面）。Struts2的拦截器设计就是基于AOP 的思想，是个比较经典的应用。</p><h4 id="4-1-2-AOP的术语"><a href="#4-1-2-AOP的术语" class="headerlink" title="4.1.2 AOP的术语"></a>4.1.2 AOP的术语</h4><ul><li><strong>切面</strong><br>切面（Aspect）是指<strong>封装横切</strong>到系统功能（例如事务处理）的类。</li><li><strong>连接点</strong><br>连接点（Joinpoint）是指<strong>程序运行中</strong>的一些<strong>时间点</strong>，例如方法的调用或异常的抛出。</li><li><strong>切人点</strong><br>切入点（Pointcut）是指<strong>需要处理</strong>的<strong>连接点</strong>。在Spring AOP 中，<strong>所有的方法执行都是连接点</strong>，而切入点是一个描述信息，它修饰的是连接点，通过切入点确定哪些连接点需要被处理。</li></ul><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191123225950652.png" alt="image-20191123225950652"></p><ul><li><strong>通知</strong><br>通知（Advice）是由切面添加到特定的连接点（满足切入点规则）的一段代码，即<strong>在定义好的切入点处所要执行的程序代码</strong>，可以将其理解为<strong>切面开启后切面的方法</strong>，因此<strong>通知是切面的具体实现</strong>。</li><li><strong>引人</strong><br>引入（Introduction）允许<strong>在现有的实现类中添加自定义的方法和属性</strong>。</li><li><strong>目标对象</strong><br>目标对象（Target Object）是指<strong>所有被通知的对象</strong>。如果AOP 框架使用运行时代理的方式（动态的AOP ）来实现切面，那么通知对象总是一个代理对象。</li><li><strong>代理</strong><br>代理（Proxy）是通知应用到目标对象之后<strong>被动态创建的对象</strong>。</li><li><strong>织人</strong><br>织入（Weaving）是<strong>将切面代码插入到目标对象上，从而生成代理对象的过程</strong>。根据不同的实现技术， AOP 织入有<strong>3</strong> 种方式：<strong>编译期织入</strong>， 需要有特殊的Java 编译器；<strong>类装载期织入</strong>， 需要有特殊的类装载器；<strong>动态代理织入</strong>，在运行期为目标类添加通知生成子类的方式。<strong>SpringAOP</strong> 框架<strong>默认</strong>采用<strong>动态代理织入</strong>，而<strong>AspectJ</strong>（基于Java 语言的AOP 框架）采用<strong>编译期织入和类装载期织入</strong>。</li></ul><h3 id="4-2-动态代理"><a href="#4-2-动态代理" class="headerlink" title="4.2 动态代理"></a>4.2 动态代理</h3><p>​        在Java中有多种动态代理技术，例如JDK、CGLIB、Javassist、ASM，其中最常用的动态代理技术是JDK和CGLIB。<strong>目前，在Spring AOP中常用JDK和CGLIB两种动态代理技术</strong>。</p><h4 id="4-2-1-JDK动态代理"><a href="#4-2-1-JDK动态代理" class="headerlink" title="4.2.1 JDK动态代理"></a>4.2.1 JDK动态代理</h4><p>​        JDK 动态代理是java.lang . reflect. ＊包提供的方式，它<strong>必须借助一个接口才能产生代理对象</strong>。因此，<strong>对于使用业务接口的类， Spring 默认使用JDK 动态代理实现AOP</strong> 。</p><p>实例演示：</p><ul><li><p>创建应用，创建接口及实现类，在src的目录下创建一个dynamic.jdk包，在该包中创建接口TestDao和接口实现类TestDaoImpl。该实现类作为目标类，在代理类中对其方法进行增强处理。</p><p>TestDao的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestDaoImpl的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaoImpl</span> <span class="keyword">implements</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"修改"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建切面类</p><p>在src目录下创建一个aspect包，在该包下创建切面类MyAspect，注意在该类中可以定义多个通知（增强处理的功能方法）。</p><p>MyAspect的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类，可以定义多个通知，即增强处理的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"模拟权限控制"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">except</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"模拟一场处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"模拟日志记录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"性能检测"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建代理类</p><p>在dynamic.jdk包中创建代理类JDKDynamicProxy。在JDK动态代理中代理类必须实现java.lang.reflect.InvocationHandler接口，并编写代理方法，在代理方法中需要通过Proxy实现动态代理。</p><p>JDKDynamicProxy的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aspect.MyAspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//    声明目标类接口对象（真实对象）</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line"><span class="comment">//    创建代理的方法，建立代理对象和真实对象的代理关系，并返回代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(TestDao testDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testDao = testDao;</span><br><span class="line"><span class="comment">//        1. 类加载器</span></span><br><span class="line">        ClassLoader cld = JDKDynamicProxy<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"><span class="comment">//        2. 被代理对象实现的所有接口</span></span><br><span class="line">        Class[] clazz = testDao.getClass().getInterfaces();</span><br><span class="line"><span class="comment">//        3. 使用代理类进行增强，返回代理后的对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(cld, clazz, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理的逻辑方法，所有动态代理类的方法调用都交给该方法处理</span></span><br><span class="line"><span class="comment">     * proxy是被代理对象</span></span><br><span class="line"><span class="comment">     * method是将要被执行的方法</span></span><br><span class="line"><span class="comment">     * args是执行方法时需要的参数</span></span><br><span class="line"><span class="comment">     * return指返回代理结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//        创建一个切面</span></span><br><span class="line">        MyAspect myAspect = <span class="keyword">new</span> MyAspect();</span><br><span class="line"><span class="comment">//        前增强</span></span><br><span class="line">        myAspect.check();</span><br><span class="line">        myAspect.except();</span><br><span class="line"><span class="comment">//        在目标类上调用方法标并传入参数，相当于调用testDao中的方法</span></span><br><span class="line">        Object obj = method.invoke(testDao, args);</span><br><span class="line"><span class="comment">//        后增强</span></span><br><span class="line">        myAspect.log();</span><br><span class="line">        myAspect.monitor();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建测试类</p><p>在dynamic.jdk包中创建测试类JDKDynamicTest。在主方法中创建代理对象和目标对象，然后从代理对象中获取对目标对象增强后的对象，最后调用该对象的添加、修改和删除方法。</p><p>JDKDynamicTest的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        创建代理对象</span></span><br><span class="line">        JDKDynamicProxy jdkProxy = <span class="keyword">new</span> JDKDynamicProxy();</span><br><span class="line"><span class="comment">//        创建目标对象</span></span><br><span class="line">        TestDao testDao = <span class="keyword">new</span> TestDaoImpl();</span><br><span class="line"><span class="comment">//        从代理对象中获取增强后的目标对象，该对象是一个被代理的对象，它会进入代理的逻辑方法invoke中</span></span><br><span class="line">        TestDao testDaoAdvice = (TestDao) jdkProxy.createProxy(testDao);</span><br><span class="line"><span class="comment">//        执行方法</span></span><br><span class="line">        testDaoAdvice.save();</span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">        testDaoAdvice.modify();</span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">        testDaoAdvice.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果：</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125173616991.png" alt="image-20191125173616991"></p></li></ul><h4 id="4-2-2-CGLIB动态代理"><a href="#4-2-2-CGLIB动态代理" class="headerlink" title="4.2.2 CGLIB动态代理"></a>4.2.2 CGLIB动态代理</h4><p>​        <strong>JDK 动态代理必须提供接口才能使用</strong>，对于<strong>没有提供接口</strong>的类，只能<strong>采用CGLIB 动态代理</strong>。</p><p>​        CGLIB (Code Generation Library ） 是一个<strong>高性能开源的</strong>代码生成包，采用非常<strong>底层</strong>的<strong>字节码技术</strong>，对指定的目标类生成一个子类，并对子类进行增强。在Spring Core 包中己经集成了CGLIB 所需要的JAR 包，不需要另外导入JAR 包。</p><p>实例演示：</p><ul><li><p>创建目标类</p><p>在src目录下创建一个dynamic.cglib包，在该包中创建目标类TestDao，注意该类不需要实现任何接口。</p><p>TestDao的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic.cglib;</span><br></pre></td></tr></table></figure></li></ul><p>public class TestDao {<br>      public void save() {<br>          System.out.println(“保存”);<br>      }</p><pre><code>public void modify() {    System.out.println(&quot;修改&quot;);}public void delete() {    System.out.println(&quot;删除&quot;);}</code></pre><p>  }</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line">- 创建代理类</span><br><span class="line"></span><br><span class="line">  在dynamic.cglib包中创建代理类CglibDynamicProxy，该类实现MethodInterceptor接口。</span><br><span class="line"></span><br><span class="line">  CglibDynamicProxy的代码如下：</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  package dynamic.cglib;</span><br><span class="line">  </span><br><span class="line">  import org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line">  import org.aopalliance.intercept.MethodInvocation;</span><br><span class="line">  import org.springframework.cglib.proxy.Callback;</span><br><span class="line">  import org.springframework.cglib.proxy.Enhancer;</span><br><span class="line">  import org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line">  </span><br><span class="line">  import java.lang.reflect.Method;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">   * @Author: yihangjou(周逸航)</span><br><span class="line">   * @Site: www.yihang.ml</span><br><span class="line">   * @cnBlogs: https:&#x2F;&#x2F;www.cnblogs.com&#x2F;yihangjou&#x2F;</span><br><span class="line">   * @Date: create in 2020&#x2F;2&#x2F;16 14:54</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public class CglibDynamicProxy implements MethodInterceptor &#123;</span><br><span class="line">      &#x2F;**</span><br><span class="line">       * 创建代理的方法，生成CGLIB代理对象</span><br><span class="line">       * target是目标对象，需要增强的对象</span><br><span class="line">       * 返回目标对象的CGLIB代理对象</span><br><span class="line">       *&#x2F;</span><br><span class="line">      public Object createProxy(Object target) &#123;</span><br><span class="line">  &#x2F;&#x2F;        创建一个动态类对象，即增强类对象</span><br><span class="line">          Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">  &#x2F;&#x2F;        确定需要增强的类，设置其父类</span><br><span class="line">          enhancer.setSuperclass(target.getClass());</span><br><span class="line">  &#x2F;&#x2F;        确定代理逻辑对象为当前对象，要求当前对象实现MethodIntercepor的方法</span><br><span class="line">          enhancer.setCallback((Callback) this);</span><br><span class="line">  &#x2F;&#x2F;        返回创建的代理对象</span><br><span class="line">          return enhancer.create();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      &#x2F;**</span><br><span class="line">       * intercept方法会在程序执行目标方法时被调用</span><br><span class="line">       * proxy时CGLIB根据指定父类生成的代理对象</span><br><span class="line">       * method是拦截方法</span><br><span class="line">       * args是拦截方法的参数数组</span><br><span class="line">       * methodProxy是方法的代理对象，用于执行父类的方法</span><br><span class="line">       * 返回代理结果</span><br><span class="line">       *&#x2F;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">          &#x2F;&#x2F;创建一个切面</span><br><span class="line">          MyAspect myAspect &#x3D; new MyAspect();</span><br><span class="line">          &#x2F;&#x2F;前增强</span><br><span class="line">          myAspect.check();</span><br><span class="line">          myAspect.except();</span><br><span class="line">          &#x2F;&#x2F;目标方法执行，返回代理结果</span><br><span class="line">          Object obj &#x3D; methodProxy.invokeSuper(proxy, args);</span><br><span class="line">          &#x2F;&#x2F;后增强</span><br><span class="line">          myAspect.log();</span><br><span class="line">          myAspect.monitor();</span><br><span class="line">          return obj;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建测试类</p><p>在dynamic.cglib包中创建测试类CglibDynamicTest。在主方法中创建代理对象和目标对象，然后从代理对象中获取对目标对象增强后的对象，最后调用该对象的添加、修改和删除方法。</p><p>CglibDynamicTest的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamic.cglib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: yihangjou(周逸航)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Site</span>: www.yihang.ml</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@cnBlogs</span>: https://www.cnblogs.com/yihangjou/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: create in 2020/2/16 15:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        CglibDynamicProxy cdp = <span class="keyword">new</span> CglibDynamicProxy();</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        TestDao testDao = <span class="keyword">new</span> TestDao();</span><br><span class="line">        <span class="comment">//获取增强后的目标对象</span></span><br><span class="line">        TestDao testDaoAdvice = (TestDao)cdp.createProxy(testDao);</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        testDaoAdvice.save();</span><br><span class="line">        System.out.println(<span class="string">"============="</span>);</span><br><span class="line">        testDaoAdvice.modify();</span><br><span class="line">        System.out.println(<span class="string">"============="</span>);</span><br><span class="line">        testDaoAdvice.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果与JDK动态代理运行效果相同。</p></li></ul><h3 id="4-3-基于代理类的AOP实现"><a href="#4-3-基于代理类的AOP实现" class="headerlink" title="4.3 基于代理类的AOP实现"></a>4.3 基于代理类的AOP实现</h3><p>​        <strong>在Spring中默认使用JDK动态代理实现AOP编程</strong>。使用org.springframework.aop.framwork.ProxyFactoryBean创建代理是Spring AOP实现的最基本方式。</p><h4 id="4-3-1-通知类型"><a href="#4-3-1-通知类型" class="headerlink" title="4.3.1 通知类型"></a>4.3.1 通知类型</h4><p>根据Spring中<strong>通知在目标类方法中的连接点位置</strong>，通知可以分为6种类型。</p><h5 id="4-3-1-1-环绕通知"><a href="#4-3-1-1-环绕通知" class="headerlink" title="4.3.1.1 环绕通知"></a>4.3.1.1 环绕通知</h5><p>​        环绕通知（org.aopallicance.intercept.MethodIntercerptor）是在<strong>目标方法执行前和执行后实施增强</strong>，可<strong>应用于日志记录、事务处理等功能</strong>。</p><h5 id="4-3-1-2-前置通知"><a href="#4-3-1-2-前置通知" class="headerlink" title="4.3.1.2 前置通知"></a>4.3.1.2 前置通知</h5><p>​        前置通知（org.springframework.aop.MethodBeforeAdvice）实在<strong>目标方法执行前实施增强</strong>，可<strong>应用于权限管理等功能</strong>。</p><h5 id="4-3-1-3-后置返回通知"><a href="#4-3-1-3-后置返回通知" class="headerlink" title="4.3.1.3 后置返回通知"></a>4.3.1.3 后置返回通知</h5><p>​        后置返回通知（org.springframework.aop.AfterReturningAdvice）是在<strong>目标方法成功执行后实施增强</strong>，可应<strong>用于关闭流、删除临时文件等功能</strong>。</p><h5 id="4-1-3-5-后置（最终）通知"><a href="#4-1-3-5-后置（最终）通知" class="headerlink" title="4.1.3.5 后置（最终）通知"></a>4.1.3.5 后置（最终）通知</h5><p>​        后置通知（org.springframework.aop.AfterAdvice）是在<strong>目标方法执行后实施增强</strong>，与后置返回通知不同的是，<strong>不管是否发生异常都要执行该类通知</strong>，该类通知可应<strong>用于释放资源</strong>。</p><h5 id="4-1-3-6-引入通知"><a href="#4-1-3-6-引入通知" class="headerlink" title="4.1.3.6 引入通知"></a>4.1.3.6 引入通知</h5><p>​        引入通知（org.springframework.aop.IntroductionInterceptor）是在<strong>目标类中添加一些新的方法和属性</strong>，可应<strong>用于修改目标类（增强类）</strong>。</p><h4 id="4-3-2-ProxyFactoryBean"><a href="#4-3-2-ProxyFactoryBean" class="headerlink" title="4.3.2 ProxyFactoryBean"></a>4.3.2 ProxyFactoryBean</h4><p>​        ProxyFactoryBean是org.springframework.beans.factory.FactoryBean接口的实现类，FactoryBean负责实例化一个Bean实例，ProxyFactoryBean负责为其他Bean实例创建代理实例。</p><p><strong>* ProxyFactoryBean类的常用属性</strong>：</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200217104715654.png" alt="image-20200217104715654"></p><h3 id="4-4-基于XML配置开发AspectJ"><a href="#4-4-基于XML配置开发AspectJ" class="headerlink" title="4.4 基于XML配置开发AspectJ"></a>4.4 基于XML配置开发AspectJ</h3><p>​        AspectJ是一个基于Java语言的AOP框架。使用AspectJ实现Spring AOP的方式有两种，一是基于XML配置开发AspectJ，二是基于注解开发AspectJ。</p><p>​        基于XML配置开发AspectJ是指通过XML配置文件定义切面、切入点及通知，所有这些定义都必须在<code>&lt;aop:config&gt;</code>元素内。<code>&lt;aop:config&gt;</code>元素及其子元素如下表所示：</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191126124023343.png" alt="image-20191126124023343"></p><p>​        <strong>各类型通知与目标方法的执行过程</strong>，具体过程如图所示：</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191126124203736.png" alt="image-20191126124203736"></p><p>案例演示：</p><ul><li><p>创建切面类</p><p>在src目录下创建aspectj.xml包，在该包下创建切面类MyAspect。</p><p>MyAspect的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aspectj.xml;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: yihangjou(周逸航)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Site</span>: www.yihang.ml</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@cnBlogs</span>: https://www.cnblogs.com/yihangjou/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: create in 2020/2/17 11:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.Joinpoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类，在此类中编写各种类型的通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知，使用JoinPoint接口作为参数获得目标对象信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Joinpoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"前置通知：模拟权限控制"</span>);</span><br><span class="line">        System.out.println(<span class="string">",目标类对象："</span> + jp.getTarget()</span><br><span class="line">        + <span class="string">",被增强处理的方法："</span> + jp.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置返回通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Joinpoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"后置返回通知："</span> + <span class="string">"模拟删除临时文件"</span>);</span><br><span class="line">        System.out.println(<span class="string">", 被增强处理的方法："</span> + jp.getSignature().getName());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 环绕通知</span></span><br><span class="line"><span class="comment">         * ProceedingJoinPoint是JoinPoint的子接口，代表可以执行的目标方法</span></span><br><span class="line"><span class="comment">         * 返回值的类型必须是Object</span></span><br><span class="line"><span class="comment">         * 必须一个参数是ProceedingJoinPoint类型</span></span><br><span class="line"><span class="comment">         * 必须throws Throwable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">//开始</span></span><br><span class="line">            System.out.println(<span class="string">"环绕开始：执行目标方法前，模拟开启事务"</span>);</span><br><span class="line">            <span class="comment">//执行当前目标方法</span></span><br><span class="line">            Object obj = pjp.proceed();</span><br><span class="line">            <span class="comment">//结束</span></span><br><span class="line">            System.out.println(<span class="string">"环绕结束：执行目标方法后，模拟关闭事务"</span>);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 异常通知</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">except</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"异常通知："</span> + <span class="string">"程序执行异常"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 后置（最终）通知</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"最终通知：模拟释放资源"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建配合文件，并编写相关配置，在aspectj.xml包中创建配置文件applicationContext.xml，并为&lt;aop: config&gt;元素及其子元素编写相关配置。</p><p>applicationContext.xml的代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    定义目标对象，使用实现类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testDao"</span> <span class="attr">class</span>=<span class="string">"dynamic.jdk.TestDaoImpl"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    创建一个切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"aspectj.xml.MyAspect"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用Spring代理工厂定义一个名为testDaoProxy的代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testDaoProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        指定代理实现的接口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"dynamic.jdk.TestDao"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        指定目标对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"testDao"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        指定切面，织入环绕通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"myAspect"</span> /&gt;</span></span><br><span class="line">        指定代理方式，true指定CGLIB动态代理；默认为false，指定JDK动态代理</span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyTargetClass"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建测试类</p><p>在aspectj.xml包中创建测试类XMLAspectJTest，在主方法中使用Spring容器获取代理对象，并执行目标方法。</p><p>XMLAspectJTest的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spring.proxyfactorybean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dynamic.jdk.TestDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: yihangjou(周逸航)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Site</span>: www.yihang.ml</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@cnBlogs</span>: https://www.cnblogs.com/yihangjou/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: create in 2020/2/17 13:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBeanTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext appCon = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"/spring/proxyfactorybean/applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//        从容器中获取增强后的目标对象</span></span><br><span class="line">        TestDao testDaoAdvice = (TestDao)appCon.getBean(<span class="string">"testDaoProxy"</span>);</span><br><span class="line"><span class="comment">//        执行方法</span></span><br><span class="line">        testDaoAdvice.save();</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        testDaoAdvice.modify();</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        testDaoAdvice.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果</p></li></ul><h3 id="4-5-基于注解开发AspectJ"><a href="#4-5-基于注解开发AspectJ" class="headerlink" title="4.5 基于注解开发AspectJ"></a>4.5 基于注解开发AspectJ</h3><p>​        基于注解开发AspectJ要比基于XML配置开发AspectJ便捷许多，所以在实际开发中推荐使用注解方法。</p><p>​        <strong>AspectJ注解</strong>，如下表所示：</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191126124359161.png" alt="image-20191126124359161"></p><p>案例演示：</p><ul><li><p>创建切面类</p><p>在src目录下创建aspectj.annotation包，在该包中创建切面类MyAspect。在该类中首先使用@Aspect注解定义一个切面类，由于该类在Spring中是作为组件使用的，所以还需要使用@Component注解；然后使用@Pointcut注解切入点表达式，并通过定义方法来表示切入点名称；最后再每个通知方法上添加相应的注解，并将切入点名称作为参数传递给需要执行增强的通知方法。</p><p>MyAspect的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>注解目标类</p><p>使用注解@Repository将目标类dynamic.jdk.TestDaoImpl注解为目标对象，注解代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>创建配置文件</p><p>在aspectj.annotation包中创建配置文件applicationContext.xml，并在配置文件中指定需要扫描的包，使注解生效，同时需要启动基于注解的AspectJ的支持。</p><p>applicationContext.xml的代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>创建测试类</p><p>测试类的运行结果与XML配置结果相同。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2. Spring IoC</title>
      <link href="/2020/02/20/Spring/%E3%80%90Spring%E3%80%912.%20Spring%20IoC/"/>
      <url>/2020/02/20/Spring/%E3%80%90Spring%E3%80%912.%20Spring%20IoC/</url>
      
        <content type="html"><![CDATA[<p><strong>控制反转（Inversion of Control，IoC）</strong>是Spring框架的核心，用来消减计算机程序的偶合问题。</p><p><strong>依赖注入（Dependency Injection，DI）</strong>是IoC的另外一种说法，只是从不同的角度描述相同的概念。</p><a id="more"></a><h2 id="2-Spring-IoC"><a href="#2-Spring-IoC" class="headerlink" title="2. Spring IoC"></a>2. Spring IoC</h2><h3 id="2-1-Spring-IoC的基本概念"><a href="#2-1-Spring-IoC的基本概念" class="headerlink" title="2.1 Spring IoC的基本概念"></a>2.1 Spring IoC的基本概念</h3><p><strong>控制反转（Inversion of Control，IoC）</strong>是Spring框架的核心，用来消减计算机程序的偶合问题。</p><p><strong>依赖注入（Dependency Injection，DI）</strong>是IoC的另外一种说法，只是从不同的角度描述相同的概念。</p><p>​        当Spring框架出现后，对象的实例不再由调用者来创建，而是由Spring容器来创建。Spring容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制。这样，<strong>控制权由调用者转移到Spring容器，控制权发生了反转</strong>，这就是<strong>Spring的控制反转</strong>。</p><p>​        从Spring容器角度来看，<strong>Spring容器负责将被依赖对象赋值给调用者的成员变量</strong>，相当于<strong>为调用者注入它所依赖的实例</strong>，这就是<strong>Spring的依赖注入</strong>。</p><p>​        综上所述，<strong>控制反转是一种通过描述（在Spring中可以是XML或注解）并通过第三方去产生或获取特定对象的方式</strong>。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入。</p><h3 id="2-2-Spring-IoC容器"><a href="#2-2-Spring-IoC容器" class="headerlink" title="2.2 Spring IoC容器"></a>2.2 Spring IoC容器</h3><h4 id="2-2-1-BeanFactory"><a href="#2-2-1-BeanFactory" class="headerlink" title="2.2.1 BeanFactory"></a>2.2.1 BeanFactory</h4><p>​        BeanFactory由org.springframework.beans.factory.BeanFactory接口定义，他提供了完整的IoC服务支持，是一个管理Bean的工厂，主要负责初始化各种Bean。BeanFactory接口有多个实现类，其中比较常用的是org.springframework.beans.factory.xml.XmlBeanFactory。</p><p>​        在创建BeanFactory实例时需要提供XML文件的绝对路径。下面是main方法中的一个示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化Spring容器，加载配置文件</span></span><br><span class="line">    BeanFactory beanFac = <span class="keyword">new</span> XmlBeanFactory(</span><br><span class="line">    <span class="keyword">new</span> FileSystemResource(<span class="string">"D:\eclipse-workspace\ch1\src\</span></span><br><span class="line"><span class="string">    applicationContext.xml"</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//通过容器获取test实例</span></span><br><span class="line">    TestDao tt = (TestDao)beanFac.getBean(<span class="string">"test"</span>);</span><br><span class="line">    tt.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-ApplicationContext"><a href="#2-2-2-ApplicationContext" class="headerlink" title="2.2.2 ApplicationContext"></a>2.2.2 ApplicationContext</h4><p>​        ApplicationContext是BeanFactory的子接口，也称为应用上下文，由org.springframework.context.ApplicationContext接口定义。ApplicationContext接口除了包含BeanFactory的所有功能以外，还添加了对国际化、资源访问、事件传播等内容的支持。</p><p>​        创建ApplicationContext接口实例通常有一下<strong>3</strong>种方法：</p><ul><li><p><strong>通过ClassPathXmlApplicationContext创建</strong></p><p>ClassPathXmlApplicationContext将从类路径目录（src根目录）中寻找指定的XML配置文件。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化Spring容器ApplicationContext，加载配置文件</span></span><br><span class="line">    ApplicationContext appCon = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">//通过容器获取test实例</span></span><br><span class="line">    TestDao tt = <span class="keyword">new</span> (TestDao)appCon.getBean(<span class="string">"test"</span>);</span><br><span class="line">    tt.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过FileSystemXmlApplicationContext创建</strong></p><p>FileSystemXmlApplicationContext将从指定文件的绝对路径中寻找XML配置文件，找到并装载完成ApplicationContext的实例化工作。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化Spring容器ApplicationContext，加载配置文件</span></span><br><span class="line">    ApplicationContext appCon = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"D:\eclipse-workspace\ch1\src\applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">//通过容器获取test实例</span></span><br><span class="line">    TestDao tt = <span class="keyword">new</span> (TestDao)appCon.getBean(<span class="string">"test"</span>);</span><br><span class="line">    tt.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用绝对路径的加载方式将导致程序的灵活性变差，一般不推荐使用。因此块，通常在Spring的Java应用中采取通过ClassPathXmlApplicationContext类来实例化ApplicationContext容器的方式，而在Web应用中，ApplicationContext容器的实例化工作将交给Web服务器完成。</p></li></ul><ul><li><p><strong>通过Web服务器实例化ApplicationContext容器</strong></p><p>在Web服务器实例化ApplicationContext容器时，一般使用基于org.framework.web.context.ContextLoaderListener的实现方式（需要将spring-web-x.x.x.RELEASE.jar复制到WEB-INF/lib目录中），此方法只需在web.xml中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载src目录下的applicationContext.xml文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">    classpath:applicationContext.xml</span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定以ContextLoaderListener方式启动Spring容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    org.framework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-依赖注入的类型"><a href="#2-3-依赖注入的类型" class="headerlink" title="2.3 依赖注入的类型"></a>2.3 依赖注入的类型</h3><p>​        在Spring中实现IoC容器的方法是依赖注入，依赖注入的作用是在使用Spring框架创建对象时动态地将其所依赖的对象（例如属性值）注入Bean组件中。Spring框架的依赖注入通常有两种实现方式，一种是使用构造方法注入，另一种是使用属性的setter方法注入。</p><h4 id="2-3-1-使用构造方法注入"><a href="#2-3-1-使用构造方法注入" class="headerlink" title="2.3.1 使用构造方法注入"></a>2.3.1 使用构造方法注入</h4><p>​        Spring框架可以采用Java的反射机制，通过构造方法完成依赖注入。</p><p>实例讲解：</p><ul><li><p>创建dao包</p><p><strong>创建dao包在service中使用构造方法依赖注入TestDIDao接口对象。</strong></p><p>TestDIDao接口代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestDIDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestDIDaoImpl实现类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDIDaoImpl</span> <span class="keyword">implements</span> <span class="title">TestDIDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        system.out.println(<span class="string">"TestDIDao say: Hello, Study hard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建service包</p><p><strong>在TestDIServiceImpl中使用构造方法依赖注入TestDIDao接口对象。</strong></p><p>TestDIService接口代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestDIService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestDIServiceImpl实现类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> dao.TestDIDao;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDIServiceImlp</span> <span class="keyword">implements</span> <span class="title">TestDIService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestDIDao testDIDao;</span><br><span class="line">    <span class="comment">//构造方法,用于实现依赖注入接口对象testDIDao</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDIServiceImpl</span><span class="params">(TestDIDao testDIDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.testDIDao = testDIDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用testDIDao中的sayHello方法</span></span><br><span class="line">        testDIDao.sayHello();</span><br><span class="line">        System.out.println(<span class="string">"TestDIService构造方法注入say: Hello, Study hard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><p>在src根目录下根目录下创建Spring配置文件applicationContext.xml。在配置文件中首先将dao.TestDIDaoImpl类托管给Spring，让Spring创建其对象，然后将service.TestDIServiceImpl类托管给Spring，让Spring创建其对象，同时给构造方法传递实参。配置文件代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">模拟spring执行过程</span></span><br><span class="line"><span class="comment">创建service实例：BookService bookService = new BookServiceImpl()IoC  &lt;bean&gt;</span></span><br><span class="line"><span class="comment">创建dao实例：BookDao bookDao = new BookDaoImpl()IoC</span></span><br><span class="line"><span class="comment">将dao设置给service：bookService.setBookDao(bookDao);DI   &lt;property&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;property&gt; 用于进行属性注入</span></span><br><span class="line"><span class="comment">name： bean的属性名，通过setter方法获得</span></span><br><span class="line"><span class="comment">setBookDao ##&gt; BookDao  ##&gt; bookDao</span></span><br><span class="line"><span class="comment">ref ：另一个bean的id值的引用</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将指定类TestDIDaoImpl配置给Spring，让Spring创建其实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTestDIDao"</span> <span class="attr">class</span>=<span class="string">"dao.TestDIDaoImpl"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用构造方法注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testDIService"</span> <span class="attr">class</span>=<span class="string">"service.TestDIServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将myTestDIDao注入到TestDIServiceImpl类的属性testDIDao上 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"myTestDIDao"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建test包</p><p>创建测试类TestDI，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> test;</span><br><span class="line">  <span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">  <span class="keyword">import</span> service.TestDIService;</span><br><span class="line">  <span class="keyword">public</span> classs TestDI &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//初始化Spring容器ApplicationContext，加载配置文件</span></span><br><span class="line">      ApplicationContext appCon = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">      <span class="comment">//通过容器获取testDIService实例，测试构造方法注入</span></span><br><span class="line">      TestDIService ts = (TestDIService)appCon.getBean(<span class="string">"testDIService"</span>);</span><br><span class="line">      ts.sayHello();</span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果：</p><p>![image-20191122090138765](E:\YihangJou\Examples Demo（SSM+SpringBoot）\A_Note\Spring\asset\image-20191122090138765.png)</p></li></ul><h4 id="2-3-2-使用属性的setter方法注入"><a href="#2-3-2-使用属性的setter方法注入" class="headerlink" title="2.3.2 使用属性的setter方法注入"></a>2.3.2 使用属性的setter方法注入</h4><p>​        使用setter方法注入是Spring框架中最主流的注入方式，它利用Java Bean规范所定义的setter方法来完成注入，灵活且可读性高。对于setter方法注入，Spring框架也是使用Java的反射机制实现的。</p><p>实例讲解：</p><ul><li><p>创建接口实现类TestDIServiceImpl</p><p>在service包中创建接口实现类TestDIServiceImpl1，在TestDIServiceImpl1中使用属性的setter方法依赖注入TestDIDao接口对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> dao.TestDIDao;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDIServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestDIService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestDIDao testDIDao;</span><br><span class="line">    <span class="comment">//添加testDIDao属性的setter方法，用于实现依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestDIDao</span><span class="params">(TestDIDao testDIDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testDIDao = testDIDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用testDIDao中的sayHello方法</span></span><br><span class="line">        testDIDao.sayHello();</span><br><span class="line">        System.out.println(<span class="string">"TestDIService setter方法注入 say: Hello, Study hard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将TestDIServiceImpl1类托管给Spring</p><p>让Spring创建其对象，同时调用TestDISeriveImpl1类的setter方法完成依赖注入。代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用setter方法注入 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"testDIService1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"service.TestDIServiceImpl1"</span>&gt;</span><br><span class="line">    &lt;!-- 调用TestDIServiceImpl1类的setter方法，将myTestDIDao注入到TestDIServiceImpl1类的属性testDIDao上 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"testDIDao"</span> ref=<span class="string">"myTestDIDao"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>在test中测试setter方法注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过容器获取testDIService实例，测试setter方法注入</span></span><br><span class="line">TestDIService ts1=(TestDIService)appCon.getBean(<span class="string">"testDIService1"</span>);</span><br><span class="line">ts1.sayHello();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>运行效果：</p><p>![image-20191123233202956](E:\YihangJou\Examples Demo（SSM+SpringBoot）\A_Note\Spring\asset\image-20191123233202956.png)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5. Spring的事务管理</title>
      <link href="/2020/02/20/Spring/%E3%80%90Spring%E3%80%915.%20Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2020/02/20/Spring/%E3%80%90Spring%E3%80%915.%20Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Spring的事务管理</p><a id="more"></a><h2 id="5-Spring的事务管理"><a href="#5-Spring的事务管理" class="headerlink" title="5. Spring的事务管理"></a>5. Spring的事务管理</h2><h3 id="5-1-Spring的数据库编程"><a href="#5-1-Spring的数据库编程" class="headerlink" title="5.1 Spring的数据库编程"></a>5.1 Spring的数据库编程</h3><h4 id="5-1-1-SpringJDBC的配置"><a href="#5-1-1-SpringJDBC的配置" class="headerlink" title="5.1.1 SpringJDBC的配置"></a>5.1.1 SpringJDBC的配置</h4><h4 id="5-1-2-SpringJdbcTemplate的常用方法"><a href="#5-1-2-SpringJdbcTemplate的常用方法" class="headerlink" title="5.1.2 SpringJdbcTemplate的常用方法"></a>5.1.2 SpringJdbcTemplate的常用方法</h4><h3 id="5-2-编程式事务管理"><a href="#5-2-编程式事务管理" class="headerlink" title="5.2 编程式事务管理"></a>5.2 编程式事务管理</h3><h4 id="5-2-1-基于底层API的编程式事务管理"><a href="#5-2-1-基于底层API的编程式事务管理" class="headerlink" title="5.2.1 基于底层API的编程式事务管理"></a>5.2.1 基于底层API的编程式事务管理</h4><h4 id="5-2-2-基于TransactionTemplate的编程式事物管理"><a href="#5-2-2-基于TransactionTemplate的编程式事物管理" class="headerlink" title="5.2.2 基于TransactionTemplate的编程式事物管理"></a>5.2.2 基于TransactionTemplate的编程式事物管理</h4><h3 id="5-3-声明式事物管理"><a href="#5-3-声明式事物管理" class="headerlink" title="5.3 声明式事物管理"></a>5.3 声明式事物管理</h3><h4 id="5-3-1-基于XML方式的声明式事务管理"><a href="#5-3-1-基于XML方式的声明式事务管理" class="headerlink" title="5.3.1 基于XML方式的声明式事务管理"></a>5.3.1 基于XML方式的声明式事务管理</h4><h4 id="5-3-2-基于-Transactional注解的声明式事务管理"><a href="#5-3-2-基于-Transactional注解的声明式事务管理" class="headerlink" title="5.3.2 基于@Transactional注解的声明式事务管理"></a>5.3.2 基于@Transactional注解的声明式事务管理</h4><h4 id="5-3-3-如何在事物管理中捕获异常"><a href="#5-3-3-如何在事物管理中捕获异常" class="headerlink" title="5.3.3 如何在事物管理中捕获异常"></a>5.3.3 如何在事物管理中捕获异常</h4>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. Spring Bean</title>
      <link href="/2020/02/20/Spring/%E3%80%90Spring%E3%80%913.%20Spring%20Bean/"/>
      <url>/2020/02/20/Spring/%E3%80%90Spring%E3%80%913.%20Spring%20Bean/</url>
      
        <content type="html"><![CDATA[<p>Spring可以看作一个大型工厂，用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持XML和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。</p><a id="more"></a><h2 id="3-Spring-Bean"><a href="#3-Spring-Bean" class="headerlink" title="3. Spring Bean"></a>3. Spring Bean</h2><h3 id="3-1-Bean的配置"><a href="#3-1-Bean的配置" class="headerlink" title="3.1 Bean的配置"></a>3.1 Bean的配置</h3><p>​        Spring可以看作一个大型工厂，用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持XML和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。</p><h4 id="3-1-1-lt-bean-gt-元素的常用属性及其子元素"><a href="#3-1-1-lt-bean-gt-元素的常用属性及其子元素" class="headerlink" title="3.1.1 &lt;bean&gt;元素的常用属性及其子元素"></a>3.1.1 <code>&lt;bean&gt;</code>元素的常用属性及其子元素</h4><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191121161451962.png" alt="image-20191121161451962"></p><h4 id="3-1-2-Bean的配置实例代码"><a href="#3-1-2-Bean的配置实例代码" class="headerlink" title="3.1.2 Bean的配置实例代码"></a>3.1.2 Bean的配置实例代码</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用id属性定义myTestDIDao，其对应的实现类为dao.TestDIDaoImpl--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTestDIDao"</span> <span class="attr">class</span>=<span class="string">"dao.TestDIDaoImpl"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用构造方法注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testDIService"</span> <span class="attr">class</span>=<span class="string">"service.TestDIServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给构造方法传引用类型的参数值myTestDIDao --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"myTestDIDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Bean的实例化"><a href="#3-2-Bean的实例化" class="headerlink" title="3.2 Bean的实例化"></a>3.2 Bean的实例化</h3><p>​        在Spring框架中，如果想使用Spring容器中的Bean，需要实例化Bean。Spring框架实例化Bean有<strong>3</strong>种方式，即<strong>构造方法实例化</strong>、<strong>静态工厂实例化</strong>、和<strong>实例工厂实例化</strong>，其中<strong>最常见</strong>的是<strong>构造方法实例化</strong>。</p><h4 id="3-2-1-构造方法实例化"><a href="#3-2-1-构造方法实例化" class="headerlink" title="3.2.1 构造方法实例化"></a>3.2.1 构造方法实例化</h4><p>​        在Spring框架中，<strong>Spring容器可以调用Bean对应类中的无参数构造方法来实例化Bean</strong>，这种方式称为构造方法实例化。</p><p>实例演示：</p><ul><li><p>创建Web应用，在src目录下创建instance包，在包中创建BeanClass类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> instance;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        message = <span class="string">"构造方法实例化Bean"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanClass</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        message = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    构造方法实例化Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"constructorInstance"</span> <span class="attr">class</span>=<span class="string">"instance.BeanClass"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> instance.BeanClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        初始化Spring容器ApplicationContext，加载配置文件</span></span><br><span class="line">        ApplicationContext appCon = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//        测试构造方法实例化Bean</span></span><br><span class="line">        BeanClass b1 = (BeanClass) appCon.getBean(<span class="string">"constructorInstance"</span>);</span><br><span class="line">        System.out.println(b1+b1.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191123112347081.png" alt="image-20191123112347081"></p></li></ul><h4 id="3-2-2-静态工厂实例化"><a href="#3-2-2-静态工厂实例化" class="headerlink" title="3.2.2 静态工厂实例化"></a>3.2.2 静态工厂实例化</h4><p>​        在使用静态工厂实例化Bean时要求开发者<strong>在工厂类中创建一个静态方法来创建Bean的实例</strong>。在配置Bean时，<strong>class属性指定静态工厂类，同时还需要使用factory-method属性指定工厂类中的静态方法</strong>。</p><p>实例演示：</p><ul><li><p>创建工厂类BeanStaticFactory，在instance包中创建工厂类BeanStaticFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanStaticFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BeanClass beanInstance = <span class="keyword">new</span> BeanClass(<span class="string">"调用静态工厂方法实例化Bean"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanClass <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    静态工厂方法实例化Bean,createInstance为静态工厂类BeanStaticFactory中的静态方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"staticFactoryInstance"</span> <span class="attr">class</span>=<span class="string">"instance.BeanStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> instance.BeanClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        初始化Spring容器ApplicationContext，加载配置文件</span></span><br><span class="line">        ApplicationContext appCon = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//        测试静态工厂方法实例化Bean</span></span><br><span class="line">        BeanClass b2 = (BeanClass) appCon.getBean(<span class="string">"staticFactoryInstance"</span>);</span><br><span class="line">        System.out.println(b2+b2.message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191124002012586.png" alt="image-20191124002012586"></p></li></ul><h4 id="3-2-3-实例工厂实例化"><a href="#3-2-3-实例工厂实例化" class="headerlink" title="3.2.3 实例工厂实例化"></a>3.2.3 实例工厂实例化</h4><p>​        在使用实例工厂实例化Bean时要求开发者<strong>在工厂类中创建一个实例方法来创建Bean的实例</strong>。在配置Bean时需要使用<strong>factory-method属性指定配置的实例工厂，同时还需要使用factory-method属性指定实例工厂中的实例方法</strong>。</p><ul><li><p>创建工厂类BeanStaticFactory</p><p>在instance包中创建工厂类BeanInstanceFactory，该类中有一个实例方法类实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanClass <span class="title">createBeanClassInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanClass(<span class="string">"调用实例工厂方法实例化Bean"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myFactory"</span> <span class="attr">class</span>=<span class="string">"instance.BeanInstanceFactory"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用factory-bean属性指定配置工厂，使用factory-method属性指定使用工厂中的哪个方法实例化Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactoryInstance"</span> <span class="attr">factory-bean</span>=<span class="string">"myFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createBeanClassInstance"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> instance.BeanClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        初始化Spring容器ApplicationContext，加载配置文件</span></span><br><span class="line">        ApplicationContext appCon = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//        测试实例工厂方法实例化Bean</span></span><br><span class="line">        BeanClass b3 = (BeanClass) appCon.getBean(<span class="string">"instanceFactoryInstance"</span>);</span><br><span class="line">        System.out.println(b3+b3.message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191124003314906.png" alt="image-20191124003314906"></p></li></ul><h3 id="3-3-Bean的作用域"><a href="#3-3-Bean的作用域" class="headerlink" title="3.3 Bean的作用域"></a>3.3 Bean的作用域</h3><h4 id="3-3-1-在Spring-5-0中为Bean的实例定义的作用域"><a href="#3-3-1-在Spring-5-0中为Bean的实例定义的作用域" class="headerlink" title="3.3.1 在Spring 5.0中为Bean的实例定义的作用域"></a>3.3.1 在<strong>Spring 5.0</strong>中为Bean的实例定义的作用域</h4><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191121163735427.png" alt="image-20191121163735427"></p><p>​        <strong>singleton</strong>和<strong>prototype</strong>是最常用的两种，后面4中作用域尽在Web Spring应用程序上下文中使用。</p><h4 id="3-3-2-singleton作用域"><a href="#3-3-2-singleton作用域" class="headerlink" title="3.3.2 singleton作用域"></a>3.3.2 singleton作用域</h4><p>​        当bean的scope设置为singleton时，<strong>Spring IoC容器仅生成和管理一个Bean实例</strong>。在使用id或name获取Bean实例时，IoC容器将会返回共享的Bean实例。</p><p>​        singleton时scope的默认方式，有两种方式将bean的scope设置为singleton。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"constructorInstance"</span> <span class="attr">class</span>=<span class="string">"instance.BeanClass"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"constructorInstance"</span> <span class="attr">class</span>=<span class="string">"instance.BeanClass"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>​        <strong>在使用id或name获取Bean实例时，IoC容器仅返回同一个Bean实例。</strong></p><h4 id="3-3-3-prototype作用域"><a href="#3-3-3-prototype作用域" class="headerlink" title="3.3.3 prototype作用域"></a>3.3.3 prototype作用域</h4><p>​        当bean的scope设置为prototype时，<strong>Spring IoC容器将为每次请求创建一个新的实例</strong>。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"constructorInstance"</span> <span class="attr">class</span>=<span class="string">"instance.BeanClass"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-Bean的生命周期"><a href="#3-4-Bean的生命周期" class="headerlink" title="3.4 Bean的生命周期"></a>3.4 Bean的生命周期</h3><ul><li>Bean的生命周期过程：</li></ul><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191121165939983.png" alt="image-20191121165939983"></p><ul><li>步骤文字描述：</li></ul><blockquote><ol><li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化。</li><li>Bean实例化后对将Bean的引入和值注入到Bean的属性中。</li><li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法。</li><li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入。</li><li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li><li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li><li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li><li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li></ol></blockquote><p>实例演示Bean的生命周期：</p><ul><li><p>创建Bean的实现类</p><p>在src目录中创建life包，在life包下创建BeanLife类。在BeanLife类中有两个方法，一个演示初始化方法，一个演示销毁过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> life;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanLife</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMyself</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">"执行自定义的初始化方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destoryMyself</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">"执行自定义的销毁方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置Bean</p><p>在Spring配置文件中使用实现类BeanLife配置一个id为beanLife的Bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置bean，使用iniit-method属性指定初始化方法，使用destroy-method属性指定销毁方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanLife"</span> <span class="attr">class</span>=<span class="string">"life.BeanLife"</span> <span class="attr">init-method</span>=<span class="string">"initMyself"</span> <span class="attr">destroy-method</span>=<span class="string">"destoryMyself"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试声明周期</p><p>在test包中创建测试类TestLife。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> life.BeanLife;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLife</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        初始化Spring容器，加载配置文件</span></span><br><span class="line"><span class="comment">//        为了方便演示销毁方法的执行，这里使用ClassPathXmlApplicationContext</span></span><br><span class="line"><span class="comment">//        实现类声明容器</span></span><br><span class="line">        ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        System.out.println(<span class="string">"获得对象前"</span>);</span><br><span class="line">        BeanLife blife = (BeanLife)ctx.getBean(<span class="string">"beanLife"</span>);</span><br><span class="line">        System.out.println(<span class="string">"获得对象后"</span> + blife);</span><br><span class="line">        ctx.close();     <span class="comment">//关闭容器，销毁Bean对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191124124333023.png" alt="image-20191124124333023"></p></li></ul><h3 id="3-5-Bean的装配方式"><a href="#3-5-Bean的装配方式" class="headerlink" title="3.5 Bean的装配方式"></a>3.5 Bean的装配方式</h3><p>​        <strong>Bean的装配</strong>可以理解为<strong>将bean依赖注入到Spring容器中</strong>，<strong>Bean的装配方式即Bean依赖注入的方式</strong>。</p><h4 id="3-5-1-基于XML配置的装配"><a href="#3-5-1-基于XML配置的装配" class="headerlink" title="3.5.1 基于XML配置的装配"></a>3.5.1 基于XML配置的装配</h4><p>​        在使用<strong>构造方法注入方式装配Bean</strong>时，Bean的实现类<strong>需要提供带参数</strong>的<strong>构造方法</strong>，并在配置文件中使用<bean>元素的子元素<constructor-arg>来定义构造方法的参数；在使用<strong>属性的setter方法注入方式装配Bean</strong>时，Bean的实现类需要提供一个<strong>默认无参数</strong>的构造方法，并为需要注入的属性提供对应的<strong>setter方法</strong>，另外还需要使用<bean>元素的子元素<property>为每个属性注入值。</p><p>实例演示：</p><ul><li><p>创建Bean的实现类</p><p>在src目录中创建assemble包，在assemble包下创建ComplexUser类。在ComplexUser类中分别使用构造方法注入和使用属性的setter方法注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> assemble;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbyList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; residenceMap;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; aliasSet;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用构造方法注入，需要提供带参数的构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComplexUser</span><span class="params">(String uname, List&lt;String&gt; hobbyList, Map&lt;String, String&gt; residenceMap, Set&lt;String&gt; aliasSet, String[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.uname = uname;</span><br><span class="line">        <span class="keyword">this</span>.hobbyList = hobbyList;</span><br><span class="line">        <span class="keyword">this</span>.residenceMap = residenceMap;</span><br><span class="line">        <span class="keyword">this</span>.aliasSet = aliasSet;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用属性的setter方法注入，提供默认无参数的构造方法，并为注入的属性提供setter方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComplexUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"uname="</span> + uname + <span class="string">";hobbyList="</span> + hobbyList + <span class="string">";residenceMap="</span> + residenceMap + <span class="string">";aliasSet="</span> + aliasSet +<span class="string">";array="</span> + array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    此处为所有属性的setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUname</span><span class="params">(String uname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbyList</span><span class="params">(List hobbyList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobbyList = hobbyList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResidenceMap</span><span class="params">(Map residenceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.residenceMap = residenceMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAliasSet</span><span class="params">(Set aliasSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aliasSet = aliasSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(String[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置Bean</p><p>在Spring配置文件中使用实现类ComplexUser配置Bean的两个实例。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    使用构造方法注入方式装配ComplexUser实例user1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user1"</span> <span class="attr">class</span>=<span class="string">"assemble.ComplexUser"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"yihang1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>唱歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>跳舞<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>爬山<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"dalian"</span> <span class="attr">value</span>=<span class="string">"大连"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"beijing"</span> <span class="attr">value</span>=<span class="string">"北京"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"shanghai"</span> <span class="attr">value</span>=<span class="string">"上海"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>逸航01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>逸航02<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>逸航03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"4"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaaaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbbbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    使用属性的setter方法注入方式装配 ComplexUser实例user2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"assemble.ComplexUser"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"uname"</span> <span class="attr">value</span>=<span class="string">"yihang2"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbyList"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>看书<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>学习Spring<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"residenceMap"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"shenzhen"</span> <span class="attr">value</span>=<span class="string">"深圳"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"guangzhou"</span> <span class="attr">value</span>=<span class="string">"广州"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"tianjin"</span> <span class="attr">value</span>=<span class="string">"天津"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"aliasSet"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>逸航04<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>逸航05<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>逸航06<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"array"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>ddddd<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试基于XML配置的装配方式</p><p>在test包中创建测试类TestAssemble。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> assemble.ComplexUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAssemble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext appCon = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//        使用构造方法装配测试</span></span><br><span class="line">        ComplexUser u1 = (ComplexUser) appCon.getBean(<span class="string">"user1"</span>);</span><br><span class="line">        System.out.println(u1);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"><span class="comment">//        使用setter方法装配测试</span></span><br><span class="line">        ComplexUser u2 = (ComplexUser) appCon.getBean(<span class="string">"user2"</span>);</span><br><span class="line">        System.out.println(u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125095824130.png" alt="image-20191125095824130"></p></li></ul><h4 id="3-5-2-基于注解的装配"><a href="#3-5-2-基于注解的装配" class="headerlink" title="3.5.2 基于注解的装配"></a>3.5.2 基于注解的装配</h4><p>​        大量的Bean装配会导致XML配置文件过于庞大，不方便以后的升级与维护，因此更多的时候推荐开发者使用<strong>注解（annotation）</strong>的方式去装配Bean。</p><h5 id="3-5-1-1-Component"><a href="#3-5-1-1-Component" class="headerlink" title="3.5.1.1 @Component"></a>3.5.1.1 @Component</h5><p>​        该注解是一个泛化的概念，仅仅表示一个组件对象（Bean），可以作用在任何层次上。</p><h5 id="3-5-2-2-Repository"><a href="#3-5-2-2-Repository" class="headerlink" title="3.5.2.2 @Repository"></a>3.5.2.2 @Repository</h5><p>​        该注解用于将数据访问层（DAO）的类标识为Bean，即注解数据访问层Bean，其功能与@Component相同。</p><h5 id="3-5-2-3-Service"><a href="#3-5-2-3-Service" class="headerlink" title="3.5.2.3 @Service"></a>3.5.2.3 @Service</h5><p>​        该注解用于标注一个业务逻辑组件类（Service层），其功能与@Component相同。</p><h5 id="3-5-2-4-Controller"><a href="#3-5-2-4-Controller" class="headerlink" title="3.5.2.4 @Controller"></a>3.5.2.4 @Controller</h5><p>​        该注解用于标注一个控制器组件类（Spring MVC的Controller），其功能与@Component相同。</p><h5 id="3-5-2-5-Autowired"><a href="#3-5-2-5-Autowired" class="headerlink" title="3.5.2.5 @Autowired"></a>3.5.2.5 @Autowired</h5><p>​        该注解可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作。通过使用@Autowired来消除setter和getter方法。默认按照Bean的类型进行装配。</p><h5 id="3-5-2-6-Resource"><a href="#3-5-2-6-Resource" class="headerlink" title="3.5.2.6 @Resource"></a>3.5.2.6 @Resource</h5><p>​        该注解与@Autowired的功能一样，区别在于该注解默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean时才会按照类型来装配注入；而@Autowired默认按照Bean的类型进行装配，如果想按照名称来装配注入，则需要和@Qualifier注解一起使用。</p><h5 id="3-5-3-7-Qualifier"><a href="#3-5-3-7-Qualifier" class="headerlink" title="3.5.3.7 @Qualifier"></a>3.5.3.7 @Qualifier</h5><p>​        该注解与@Aitowired注解配合使用。当@Autowired注解需要按照名称来装配注入时需要和该注解一起使用，Bean的实例名称由@Qualifier注解的参数制定。</p><p>实例演示：</p><ul><li><p>创建DAO层</p><p>在src中创建annotation.dao包，在该包下创建TestDao接口和TestDaoImpl实现类，并将实现类TestDaoImpl使用@Repository注解标注为数据访问层。</p><p>TestDao的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestDaoImpl的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"testDao"</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相当于<span class="doctag">@Repository</span>，但如果在service层中使用<span class="doctag">@Resource</span>(name="testDao"),</span></span><br><span class="line"><span class="comment"> * testDao不能省略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaoImpl</span> <span class="keyword">implements</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testDao save"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Service层</p><p>在src中创建annotation.service包，在该包下创建TestService接口和TestServiceImpl实现类，并将实现类TestServiceImpl使用@service注解标注为业务逻辑层。</p><p>Testservice的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestServiceImpl的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> annotation.dao.TestDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"testService"</span>)  <span class="comment">//相当于@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerivceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Resource(name="testDao")</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="comment">//    相当于@Autowired，@Autowired默认按照Bean状态装配</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testDao.save();</span><br><span class="line">        System.out.println(<span class="string">"testService save"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Controller层</p><p>在src中创建annotation.controller包，在该包下创建TestController类，并将TestController类使用@Controller注解标注为控制器层。</p><p>TestController的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> annotation.service.TestService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testService.save();</span><br><span class="line">        System.out.println(<span class="string">"testController save"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置注解</p><p>由于annotation.dao、annotation.service和annotation.controller包都属于annotation包的子包，因此不要在配置文件annotationContext.xml中配置注解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"annotation"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> annotation.controller.TestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMoreAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext appCon = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"annotationContext.xml"</span>);</span><br><span class="line">        TestController testcon = (TestController) appCon.getBean(<span class="string">"testController"</span>);</span><br><span class="line">        testcon.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果</p><p><img src="C:%5CUsers%5CPedro%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191125163656863.png" alt="image-20191125163656863"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>物料生产管理系统</title>
      <link href="/2020/02/20/%E9%A1%B9%E7%9B%AE/%E7%89%A9%E6%96%99%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/02/20/%E9%A1%B9%E7%9B%AE/%E7%89%A9%E6%96%99%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>基于物料的生产管理系统具备物料采购，仓储，产成品管理以及成品审核等多种功能。</p><a id="more"></a><h2 id="物料生产管理系统"><a href="#物料生产管理系统" class="headerlink" title="物料生产管理系统"></a>物料生产管理系统</h2><h3 id="1-技术栈"><a href="#1-技术栈" class="headerlink" title="1. 技术栈"></a>1. 技术栈</h3><p>（1）后端</p><ul><li>Spring Boot</li><li>MySQL</li><li>Spring Securtiy</li><li>Redis</li></ul><p>（2）前端</p><ul><li>Vue.js</li><li>Element-UI</li><li>eCharts</li></ul><h3 id="2-界面设计"><a href="#2-界面设计" class="headerlink" title="2. 界面设计"></a>2. 界面设计</h3><p><img src="E:%5CYihangJou%5CBlog%5Csource_posts%5C%E7%89%A9%E6%96%99%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.assets%5Cimage-20200325185414138.png" alt="image-20200325185414138"></p><p><img src="E:%5CYihangJou%5CBlog%5Csource_posts%5C%E7%89%A9%E6%96%99%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.assets%5Cimage-20200325185451737.png" alt="image-20200325185451737"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
