{"meta":{"title":"都说酒是陈的香","subtitle":"三亩地","description":"周逸航的个人博客站点","author":"周逸航","url":"https://www.yihang.ml","root":"/"},"pages":[{"title":"","date":"2020-04-27T11:41:50.365Z","updated":"2020-04-27T11:41:50.365Z","comments":true,"path":"404.html","permalink":"https://www.yihang.ml/404.html","excerpt":"","text":"--- layout: page title: 404 Not Found body: [article, comments] meta: header: [] footer: [] sidebar: [] valine: path: /404.html placeholder: 请留言告诉我您要访问哪个页面找不到了 --- 404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-04-28T05:31:10.510Z","updated":"2020-04-28T05:31:10.510Z","comments":true,"path":"avatar/widget.json","permalink":"https://www.yihang.ml/avatar/widget.json","excerpt":"","text":"{\"widget\":{\"blogger\":{\"class\":\"blogger\",\"display\":[\"desktop\",\"mobile\"],\"avatar\":\"avatar/avatar.png\",\"shape\":\"rectangle\",\"url\":\"/about/\",\"title\":null,\"subtitle\":null,\"jinrishici\":true,\"social\":true},\"toc\":{\"class\":\"toc\",\"display\":[\"desktop\",\"mobile\"],\"header\":{\"icon\":\"fas fa-list\",\"title\":\"本文目录\"},\"list_number\":false,\"min_depth\":2,\"max_depth\":5},\"category\":{\"class\":\"category\",\"display\":[\"desktop\"],\"header\":{\"icon\":\"fas fa-folder-open\",\"title\":\"文章分类\",\"url\":\"/blog/categories/\"}},\"tagcloud\":{\"class\":\"tagcloud\",\"display\":[\"desktop\",\"mobile\"],\"header\":{\"icon\":\"fas fa-tags\",\"title\":\"热门标签\",\"url\":\"/blog/tags/\"},\"min_font\":14,\"max_font\":24,\"color\":true,\"start_color\":\"#999\",\"end_color\":\"#555\"},\"related_posts\":{\"class\":\"related_posts\",\"display\":[\"desktop\",\"mobile\"],\"header\":{\"icon\":\"fas fa-bookmark\",\"title\":\"相关文章\"},\"max_count\":5},\"copyright\":{\"class\":\"copyright\",\"display\":[\"desktop\",\"mobile\"],\"blockquote\":true,\"permalink\":\"本文永久链接是：\",\"content\":[\"博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议\",\"permalink\"]},\"donate\":{\"class\":\"qrcode\",\"display\":[\"desktop\",\"mobile\"],\"height\":\"64px\",\"fancybox\":true,\"images\":[\"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png\",\"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png\"]},\"references\":{\"class\":\"references\",\"display\":[\"desktop\",\"mobile\"],\"header\":{\"icon\":\"fas fa-quote-left\",\"title\":\"参考资料\"}},\"related_repos\":{\"class\":\"references\",\"display\":[\"desktop\",\"mobile\"],\"header\":{\"icon\":\"fab fa-github\",\"title\":\"源码链接\"}}}}"},{"title":"关于","date":"2020-04-27T10:26:09.000Z","updated":"2020-07-15T15:18:52.231Z","comments":true,"path":"about/index.html","permalink":"https://www.yihang.ml/about/index.html","excerpt":"","text":"联系方式 手机：17371248552（湖北武汉） Email：yihangjou@163.com 微信号：zyh1987247505 个人信息 周逸航/男/1996 本科/武汉学院 软件工程 工作年限：1年 技术博客：http://www.yihang.ml 博客园：http://www.cnblogs.com/yihangjou Github：http://github.com/joues 期望职位：Java开发工程师 期望薪资：面议 工作经历惠州市飞讯软件服务有限公司（ 2019年9月 ~ 至今 ）武汉虹信5G智慧工厂二期建设项目我在此项目中负责基础数据模块和SRM模块的编码工作。其中基础基础模块为本人独立开发完成，SRM模块混合开发实现。在整个项目开发过程中我遇到的最大问题就是无法实现并发控制项目进度，从而影响整个开发进度。我采取的措施是配合项目提升本项目组项目微调能力，这个项目中，我学到的最重要的就是团队协作，以及和同事、领导沟通的重要性。 武汉虹信5G智慧工厂二期建设项目采用了微服务架构，整体拆分为26个微服务，参与项目组及开发人员较多，本人在整个项目开发过程中的工作内容如下： 参与前期项目需求分析评分； 参与项目原型设计工作以及2、3轮甲方顾问原型审批调整工作； 参与项目开发文档撰写以及数据库表设计工作； 参与项目开发培训，前期独立实现基础数据微服务搭建，配合前端人员，完成基础数据模块的编码工作； 基础数据微服务部署中台Devops后，负责后续维护工作，并开始参与到SRM供应商采购开发模块的编码工作中； 参与项目测试，配合开发小组提交测试文档； 飞讯知识库项目我在此项目负责了飞讯软件开发平台BS开发知识库创建工作，并负责了整个BS项目开发的文档撰写工作。 武汉筋斗云无线科技有限公司 （ 2019年6月 ~ 2019年9月 ）慧学堂在线学校1.0项目我在此项目负责了前端Web页面编码工作，主要使用了Vue.js框架实现了该网站前端页面的编码，这个项目中，我最困难的问题主要是页面样式的调整，我采取了由简单到复杂、以及自我学习方式，最后基本达到项目一期要求。 本人在整个项目开发过程的工作内容如下： 参与项目前端需求分析及代码实现讨论工作； 负责BS前端交互和展示页面的编码工作； 与后台开发人员协调数据接口对接等问题； 开源项目和作品开源项目 erp：项目主要采用了Spring Boot + Vue.js技术实现了一个前后端分离物料生产管理系统。系统主要包含：用户权限控制、数据表增删改查、缓存、消息发送等功能。 技能清单以下均为我熟练使用的技能 Web开发：JavaScript/Vue.js/Html/CSS 前端工具：Element-UI/iView-UI Java技术：Java基础/Spring、Spring MVC、Mybatis/Spring Boot/Spring Cloud Java工具：Idea/Maven/Lombok 数据库相关：MySQL/SQL Server/Redis 版本管理、文档和自动化部署工具：Svn/Git ​ 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。 联系方式： 电话: 17371248552"},{"title":"友链","date":"2020-04-27T11:36:12.973Z","updated":"2020-04-27T11:36:12.973Z","comments":true,"path":"friends/index.html","permalink":"https://www.yihang.ml/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-27T10:26:09.000Z","updated":"2020-04-27T10:52:07.109Z","comments":true,"path":"tags/index.html","permalink":"https://www.yihang.ml/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-27T10:26:09.000Z","updated":"2020-04-27T11:01:39.526Z","comments":true,"path":"categories/index.html","permalink":"https://www.yihang.ml/categories/index.html","excerpt":"","text":"Servlet、Jsp Spring Java 项目"}],"posts":[{"title":"CentOS常用命令","slug":"Linux/CentOS常用命令","date":"2020-07-03T05:11:57.000Z","updated":"2020-07-05T06:47:48.870Z","comments":true,"path":"2020/07/03/Linux/CentOS常用命令/","link":"","permalink":"https://www.yihang.ml/2020/07/03/Linux/CentOS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"Git常用命令（必备） Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库","text":"Git常用命令（必备） Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 1.Linux目录结构 一、常用命令1．命令的格式 命名名称 [-options] [parameter]提示: 可选项和参数是可以省略的。2．ls 列出当前目录下的所有子目录和文件。（1）-a 显示所有的内容，包括隐藏文件(.开头的文件) . …（2）-l 列出文件的详情信息，（3）-lh 更加人性化显示3．cd 切换目录命令基本格式: cd 路径cd /home/liurui/Desktopcd /root/Desktop快捷操作:（1）cd 切换到当前的家目录下 /home/用户名 root用户 /root（2）cd ~ 同上（3）cd . 切换到当前目录（4）cd … 返回上一层目录4．相对路径和绝对路径（1）绝对路径 从根目录下开始查找 /etc/xxx（2）相对路径 从当前目录开始， ./ 或者 …/5．touch 创建文件格式: touch 文件名称。提示: 如果 创建的文件存在，则会修改末次日期。6．mkdir 创建目录格式: mkdir 目录名称 只能创建一层目录mkdir -p 多层目录 递归创建多层目录。提示: 如果目录已经存在，则不能创建。 7．rm 删除 文件或者目录（1）删除文件格式: rm [-f] 文件名称。-f 表示强制删除，（2）删除目录格式: rm -r[f] 目录名称。 8．拷贝拷贝文件格式: cp 源文件 目标目录拷贝目录格式: cp -r 源目录 目标目录 9．移动或者重命名移动格式: mv 文件/目录 目标目录重命名: mv 文件/目录 目标目录/新文件名、目录名称。 10．pwd 查看当前路径（1）格式: pwd11．cat 查看文件的内容，将内容全部显示出来。（1）格式: cat [-nb] 文件名称-n 所有的行都显示行号。-b 空行不显示行号。提示: 适合查看内容少的文件。12．more、less 查看文件内容。不会将全部内容显示出来。选项:空格：显示下一屏Enter:显示下一行b: 显示上一屏f: 显示下下一屏q: 退出————————————————版权声明：本文为CSDN博主「飞行员红猪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/aixiangnan/java/article/details/89329315","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.yihang.ml/categories/Linux/"}],"tags":[]},{"title":"Git常用命令（必备）","slug":"Git/Git常用命令（必备）","date":"2020-05-29T15:11:57.000Z","updated":"2020-06-04T16:28:53.551Z","comments":true,"path":"2020/05/29/Git/Git常用命令（必备）/","link":"","permalink":"https://www.yihang.ml/2020/05/29/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E5%BF%85%E5%A4%87%EF%BC%89/","excerpt":"Git常用命令（必备） Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库","text":"Git常用命令（必备） Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 Git常用命令（必备） Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 1.新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 2.配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 3.增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 4.代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 5.分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote&#x2F;branch] 6.标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs&#x2F;tags&#x2F;[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 7.查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty&#x3D;format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 8.远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 9.撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 10.其他123# 生成一个可供发布的压缩包$ git archive","categories":[{"name":"Git","slug":"Git","permalink":"https://www.yihang.ml/categories/Git/"}],"tags":[]},{"title":"JSP","slug":"Servlet、Jsp/【Servlet-Jsp】JSP","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:36:49.679Z","comments":true,"path":"2020/02/20/Servlet、Jsp/【Servlet-Jsp】JSP/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91JSP/","excerpt":"JSP 1. 建立JSP JSP最终会变成一个完整的servlet在Web容器中运行。","text":"JSP 1. 建立JSP JSP最终会变成一个完整的servlet在Web容器中运行。 JSP1. 建立JSP JSP最终会变成一个完整的servlet在Web容器中运行。 scriptlet就是放在&lt;% … %&gt;标记中的Java代码。 scriptelet代码会放在生成的servlet的服务方法中。 指令有3中：page、include、taglib 2. page指令 导入单个包：&lt;% @ page import=&quot;...&quot; %&gt; 导 入多个包，用逗号分离多个包。 Java代码放在带百分号的尖括号中间，指令会为元素开始记号再增加一个字符@。 page指令的属性： import isThreadSafe contentType：定义JSP响应的MIME内容。 isElIgnored：定义转化页面时是否忽略EL表达式。 isErrorPage：定义当前页面是否是另一个JSP的错误页面，默认false，不能使用隐式的exception对象。 errorPage：定义一个资源的URL language：定义scriptlet、表达式和声明中使用的脚本语言。现在可取值只有java。 extends；JSP变成servlet类后集成的类 session：定义页面是否有隐式的session对象，默认true。 buffer：定义隐式out对象如何处理缓存。 autoFlush：定义缓存的输出是否自动刷新输出，默认是true。 info：定义放到转换后页面中的串，这样能使用所生成servlet继承的getServletInfo()方法来得到这个信息。 pageEncoding：定义编码。 3. 表达式 表达式会为元素的开始记号增加一个字符：=。 表达式最后没有分号。 所有scriptlet中声明的变量总是局部变量。 4. JSP声明 JSP声明用于声明所生成servlet类的成员，变量和方法都可以声明。 JSP声明会为元素的开始记号增加一个字符：！ JSP声明的所有内容都会增加到类中，并且置于服务方法之外。 可以声明静态变量和方法。 5. JSP隐式对象 out——JspWriter request response session application——ServletContext config——ServletConfig exception(只有指定的错误页面才能用这个隐式对象） pageContext——PageContext page——Object 可以覆盖jspInit方法。 可以在配置文件中配置jsp初始化参数。 6. JSP中的属性 JSP会使用4个隐式对象之一来得到和设置对应JSP中4个属性作用域的属性： 应用：application 请求：request 会话：session 页面：pageContext 可以使用PageContext引用来得到任意作用域的属性。 PageContext类中保存着作用域常量。 findAttribute方法用来查找一个属性。 findAttribute会现在页面上下文查找，如果没有，就会先在请求作用域查找，再查找会话作用域，最后查找应用作用域，找到就截止。 7. taglib指令 定义JSP可以使用的标记库。 8. include指令 定义在转换时增加到当前页面的文本和代码。用来增加重复使用的代码。","categories":[{"name":"Servlet、Jsp","slug":"Servlet、Jsp","permalink":"https://www.yihang.ml/categories/Servlet%E3%80%81Jsp/"}],"tags":[]},{"title":"会话状态","slug":"Servlet、Jsp/【Servlet-Jsp】会话状态","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:38:56.229Z","comments":true,"path":"2020/02/20/Servlet、Jsp/【Servlet-Jsp】会话状态/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81/","excerpt":"会话状态 会话管理 HttpSession对象可以保存跨同一个客户多个请求的会话状态。","text":"会话状态 会话管理 HttpSession对象可以保存跨同一个客户多个请求的会话状态。 会话状态1. 会话管理 HttpSession对象可以保存跨同一个客户多个请求的会话状态。 HTTP协议使用的是无状态连接，客户浏览器与服务器建立连接，发出请求，得到响应，然后关闭连接。连接只为一个请求/响应存在。 对容器而言，每个请求都来自与一个新的客户。 如果用户登录，而且连接是安全的(HTTPS)，容器就能准确的知道是哪一个客户，但是条件太苛刻，一般不满足。 客户需要一个唯一的会话ID。 容器和客户通过cookie交换会话ID信息。 Set-Cooke和Cookie只是响应和请求中发送的另一个首部。 容器会做cookie的所有工作。 isNew方法可以判断会话是否是新的。 也可以通过与会话相关的事件监听器得到一个会话。 如果不想要一个新会话，可以使用getSession(false)方法。 2. URL重写 当客户不接受cookie时，使用URL重写来传递会话ID。 禁用cookie的客户会忽略Set-Cookie响应首部。 容器默认先使用cookie，如果使用cookie失败才会使用URL重写。 当想把请求重定向到另外一个URL但还想使用一个会话时，可以使用response.encodeRedirectURL()方法。 URL编码只和响应有关，只能在HttpServletResponse对象上调用。 3. 删除回话 会话对象占用着资源，不应该过久地保留。 HttpSession接口的方法： getCreationTime()返回第一次创建会话的时间。 getLastAccessedTime()返回容器最后一次得到包含这个会话ID的请求后，过去多少时间（毫秒）。 setMaxInactiveInterval()指定对于这个会话客户请求的最大间隔时间。 getMaxInactiveInterval()返回对于这个会话客户请求的最大时间间隔。 invalidate()结束回话，当前存储在这个会话中的所有属性也会解除绑定。 会话有3种死法： 超时 在会话对象上调用invalidate() 应用结束 可以在配置文件中配置会话超时。&lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; 配置的单位是分钟。 使用session.setMaxInactiveInterval()单位是秒。 会话的超时时间设置为-1时，永远不到期。 4. 定制cookie cookie实际就是在客户和服务器之间交换的一小段数据。 cookie默认与会话的寿命一样长。可以让cookie活的更长一些 使用cookie.setMaxAge()定义生命长度，秒为单位。设为-1时，浏览器退出cookie就消失。 使用response.addCookie()方法把cookie发给客户。 使用request.getCookies()得到请求的cookie数组。 cookie和首部不同，响应增加首部时，要把名和值String作为参数传入，响应增加Cookie时，要传递一个Cookie对象。 cookie没有setCookie方法。 5. 会话生命周期事件 生命周期 创建会话 撤销会话 监听者类型：HttpSessionListener 属性 增加一个属性：setAttribute()。 删除一个属性；removeAttribute()。 替换一个属性：setAttribute()。 监听者类型：HttpSessionAttributeListener 迁移 会话准备钝化：在会话移动之前调用。 会话已经激活：容器已经把会话迁移到另一个VM中。在应用的其他部分调用getAttribute()之前调用。 监听者类型：HttpSessionActivationListener HttpSessionBindingListener对应会话属性一生中的关键时刻。 会话绑定监听者不在配置文件中配置。 6. 会话迁移 只有HttpSession对象及其属性会从一个VM移动到另一个VM。 每个VM有一个ServletContext，每个VM的每个servlet有一个ServletConfig。 只有一个HttpSession对象，不论应用分布在多少个VM上。 非串行化属性需要让其属性对象类实现HttpSessionActivationListener，并使用激活/钝化回调方法解决这个问题。","categories":[{"name":"Servlet、Jsp","slug":"Servlet、Jsp","permalink":"https://www.yihang.ml/categories/Servlet%E3%80%81Jsp/"}],"tags":[]},{"title":"属性和监听者","slug":"Servlet、Jsp/【Servlet-Jsp】属性和监听者","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:40:52.889Z","comments":true,"path":"2020/02/20/Servlet、Jsp/【Servlet-Jsp】属性和监听者/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%91%E5%90%AC%E8%80%85/","excerpt":"属性和监听者 1. servlet初始化参数 可以在配置文件中给一个servlet配置初始化参数。 在servlet代码中调用getServletConfig().getInitParameter()获取。","text":"属性和监听者 1. servlet初始化参数 可以在配置文件中给一个servlet配置初始化参数。 在servlet代码中调用getServletConfig().getInitParameter()获取。 属性和监听者1. servlet初始化参数 可以在配置文件中给一个servlet配置初始化参数。 在servlet代码中调用getServletConfig().getInitParameter()获取。 在servlet初始化之前不能使用servlet初始化参数。 servlet初始化参数只能在容器初始化servlet时读一次。 2. 上下文初始化参数 上下文初始化参数对整个Web应用都可用。 在servlet代码中调用getServletContext().getInitParameter()获取。 每一个servlet有一个ServletConfig。 每一个Web应用有一个ServletContext。 如果应用是分布式的，每个JVM有一个ServletContext。 ServletConfig对象拥有该servlet的ServletContext的引用。 3. 监听者类 监听ServletContext的初始化和撤销事件，这个类实现了ServletContextListener。 不只面向上下文事件，还可以监听与上下文属性、servlet请求和属性，以及HTTP会话和会话属性相关的事件。 8个监听者； ServletContextAttributeListener HttpSessionListener ServletRequestListener ServletRequestAttributeListener HttpSessionBindingListener HttpSessionAttributeListener ServletContextListener HttpSessionActivationListener HttpSessionAttributeListener，当会话中增加、删除、或替换了某种类型的属性时能知道。 HttpSessionBindingListener，属性本身能够在增加到一个会话或者从会话删除时或的通知。 容器会通过注册监听者的顺序进行通知。 ４. 属性 属性就像是钉到公告栏上的一个对象。 三个作用域；上下文，请求和会话。 分别由ServletContext，ServletRequest和HttpSession接口处理。 上下文作用域不是线程安全的！ 同步服务方法并不能保护上下文属性。 同步服务方法只能不让同一servlet的新请求访问上下文属性，但是无法杜绝其他servet访问。 需要对上下文加锁，而不是对servlet加锁。synchronized(getServletContext()){ ... } 会话属性同样是线程不安全的，一个会话有可能由多个请求（新的浏览器窗口）。 对会话属性也采用上锁的方法，对HttpSession对象同步。synchronized(session){ ... } 同步代码会导致大量的开销，也会妨碍并发性。 只有请求属性和局部变量是线程安全的。 5. 请求属性和请求分派 如果希望应用的其他组件接管全部或部分请求，就可以使用请求属性。 RequestDispatcher可以让组件的其他部分接管请求。 RequestDispatcher只有两个方法：forward()和include()。 可以通过ServletRequest得到RequestDispatcher，参数是相对路径。 可以通过ServletContext得到RequestDispatcher，参数必须使用斜线。 如果已经提交了响应，就不能再转发请求！","categories":[{"name":"Servlet、Jsp","slug":"Servlet、Jsp","permalink":"https://www.yihang.ml/categories/Servlet%E3%80%81Jsp/"}],"tags":[]},{"title":"请求和响应","slug":"Servlet、Jsp/【Servlet-Jsp】请求与响应","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:39:33.147Z","comments":true,"path":"2020/02/20/Servlet、Jsp/【Servlet-Jsp】请求与响应/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/","excerpt":"请求和响应 1. servlet的生命周期 如果servlet没有初始化，则要么正在初始化，正在撤销，要么就是不存在。","text":"请求和响应 1. servlet的生命周期 如果servlet没有初始化，则要么正在初始化，正在撤销，要么就是不存在。 请求和响应1. servlet的生命周期 如果servlet没有初始化，则要么正在初始化，正在撤销，要么就是不存在。 Web容器加载servlet类。 初始化servlet（构造函数运行） init() (在servlet一生中只调用一次，而且必须在容器调用service()之前完成) service() (servlet一生主要都在这里度过，用于处理客户请求) destroy() （在servlet被垃圾回收之前有机会清理资源，与init()一样，destroy()也只能调用一次) 构造函数使servlet类成为对象。 init方法在servlet实例创建后，在service方法之前调用。 service方法在第一个客户请求到来时，容器会开始一个新线程，或者从线程池分配一个线程。 doGet和doPost方法：service方法根据请求的HTTP方法调用。 每个请求都在一个单独的线程中运行。 容器运行多个线程来处理一个servlet的多个请求。 每个客户请求都会生成一对新的请求和响应对象。 在调用构造函数和init方法之间，servlet处在一种薛定谔servlet状态。 薛定谔状态：既没有完全死，也不完全活，介于二者之间的一个状态。 每个servlet都有一个ServletConfig对象。 用于向servlet传递部署时信息。 用于访问ServletContext 参数在部署描述文件中配置。 每个web应用只有一个ServletContext。 2. GET和POST 除了GET和POST外，Http方法还有HEAD、TRACE、OPTIONS、PUT、DELETE、CONNECT方法。 HttpServlet中没有doConnect方法，其他都有。 Get参数数据只能是放在请求行的内容，对参数数据有限制。 POST有一个消息体，存放参数数据。 GET不会对服务器做出任何改变，只用来获取某些东西。 POST用于发送数据进行处理。 3. 幂等 幂等：反复做同一件事，不会有预料不到的副作用。 GET、HEAD、PUT是幂等的。 POST不是幂等的。 默认是GET请求。 4. 请求方法 getHeader方法获得客户平台和浏览器信息。 getCookies方法获得与请求相关的cookie。 getSession方法获得与客户相关的会话。 getMethod方法获得请求的HTTP方法。 getInputStream方法获得请求输入流。 getRemotePort方法指得到客户的端口。 对于一个servlet，远程意味着客户。 getLocalPort方法指请求最后发送到哪个端口。 getServerPort方法指请求原来发送到哪个端口。 5. 响应方法 setContextType方法设置MIME类型。 setContextType方法可以告诉浏览器发回东西的类型，可能需要启动一个辅助应用。 常见的MIME类型： text/html application/pdf video/quicktime application/java image/jpeg application/jar application/octet-stream application/x-zip getWriter获得字符输出流。 getOutputStream获得字节输出流。 6. 字节和字符输出流 PrintWriter用于输出字符数据。 ServletOutputStream用于输出字节。 println写至PrintWriter。 write挟制ServletOutputStream。 7. 增加和设置响应首部 setHeader方法：如果响应中已经有同名的首部，则用这个值替换原来的值，否则增加一个新首部和值。 addHeader方法：为响应新增加一个首部和值，或者向现有的首部增加一个值。 setIntHeader方法：用提供的整数值替换现有首部的值，或者向响应增加一个新首部和值。 如果相应中没有首部，setHeader和addHeader会增加一个首部和相应的值。 如果已经有首部，setHeader会覆盖现有的值，addHeader将增加一个值。 8. 重定向和转发1. 重定向 请求重定向让客户完成工作。 servlet调用sendRedirect方法重定向。 不能在写到响应之后再调用sendRedirect()。 在servlet中应该明确，要么处理请求，要么调用sendRedirect()让别人处理请求。 sendRedirect()取一个String，不是URL对象。 用户会在地址栏看到新的URL。 2. 转发 请求转发在服务器端工作。 浏览器地址栏URL没有变化。","categories":[{"name":"Servlet、Jsp","slug":"Servlet、Jsp","permalink":"https://www.yihang.ml/categories/Servlet%E3%80%81Jsp/"}],"tags":[]},{"title":"无脚本的JSP","slug":"Servlet、Jsp/【Servlet-Jsp】无脚本的JSP","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:41:36.739Z","comments":true,"path":"2020/02/20/Servlet、Jsp/【Servlet-Jsp】无脚本的JSP/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91%E6%97%A0%E8%84%9A%E6%9C%AC%E7%9A%84JSP/","excerpt":"无脚本的JSP 1. JavaBean标准动作 1. &lt;jsp:useBean&gt;和&lt;jsp:getProperty&gt;","text":"无脚本的JSP 1. JavaBean标准动作 1. &lt;jsp:useBean&gt;和&lt;jsp:getProperty&gt; 无脚本的JSP1. JavaBean标准动作1. &lt;jsp:useBean&gt;和&lt;jsp:getProperty&gt; &lt;jsp:useBean&gt;标签用来声明和初始化在&lt;jsp:getProperty&gt;标签中使用的具体的bean对象。 &lt;jsp:useBean&gt;声明初始化一个bean属性时，要声明id，class，scope。 &lt;jsp:getProperty&gt;得到bean属性时，要有name和property属性值。 &lt;jsp:useBean&gt;还可以创建一个bean。 可以使用&lt;jsp:setProperty&gt;设置一个属性值。 &lt;jsp:useBean&gt;可以有体，可以把设置方法放在体内。 体中的代码会有条件的运行，只有找不到bean而且创建一个新bean时才会执行。 type属性可以是class类型，抽象类型或者借口，只要能作为bean对象class类型的声明引用类型。class必须时type的一个子类或者具体实现。 如果使用type，没有class，bean必须已经存在。 如果使用了class，class不能是抽象类，而且必须有一个无参数的构造函数。 scope默认属性为page。 type == 引用类型（可以抽象） class == 对象类型（必须具体） 脚本可以放在标准动作内部。 2. 性质和请求参数 param属性可以把bean的性质值设置为一个请求参数的值。 如果请求参数名与bean性质名匹配，就不需要在&lt;jsp:setProperty&gt;标记中为该性质指定值。 如果所有请求参数名与bean性质名匹配，可以把property设置为*自动匹配所有性质。 Bean标记会自动转换String或基本类型的性质。 使用脚本时不会完成自动转换。 2. EL表达式 打印嵌套性质使用EL表达式非常容易。 EL表达式总是放在大括号里，而且前面有一个美元符前缀：${...} 表达式的第一个命名变量可以使一个隐式对象，也可以是一个属性。 1. 点号操作符 如果表达式中变量后面有一个点号，点号左边的变量必须是一个Map或bean。 点号右边必须是一个Map键或一个bean的属性。 除pageContext隐式对象是一个bean，其他都是Map。 如果不能用作为Java代码中的变量名，就不能放在点号后面。 2. []操作符 使用[]时，左边可以是List或数组，右边可以是一个数，或者解析为一个数。 中括号里可以是Map键，可以是bean性质，也可以是数组或list的索引。 数组和List中的String索引会强制转换为int 对于bean和Map，这两个操作符都可以用。 如果中括号中不是String直接量，就会计算。 在中括号中可以使用嵌套表达式。 3. EL隐式对象 pageScope requestScope sessionScope applicationScope param paramValues header headerValues cookie initParam pageContext 使用requestScope对象，可以把属性名放在引号中。 3.EL函数 函数方法必须是公共、静态的。 需要编写标记库描述文件（TLD）。 在JSP中放一个taglib指令。 taglib指令中的uri要和配置文件中的uri匹配。 EL能友好地处理null，算术表达式中看做0，逻辑表达式中看做false。 4. 布局模板1. include指令 &lt;%@ include file=&quot;***&quot; %&gt; 2. &lt;jsp:include&gt;标准动作 &lt;jsp:include page=&quot;***&quot;/&gt; 内部原理并不相同。include指令在转换时发生。标准动作在运行时发生。 include指令相当于把目标JSP内容复制到本JSP中。 include标准动作会在运行时插入目标JSP的响应。 5. 使用&lt;jsp:param&gt;定制包含的内容 在include标准动作中使用&lt;jsp:param&gt; 6. &lt;jsp:forward&gt;标准动作 可以从一个JSP转发到另一个JSP，或者从一个JSP转发到一个servlet，还可以从一个JSP转发到Web应用中的任何其他资源。 尽量少使用，视图就是视图，控制逻辑交给控制层。 发生转发时，请求转发到的目标资源首先会清空响应缓存区。","categories":[{"name":"Servlet、Jsp","slug":"Servlet、Jsp","permalink":"https://www.yihang.ml/categories/Servlet%E3%80%81Jsp/"}],"tags":[]},{"title":"0. Spring项目搭建","slug":"Spring/【Spring】0. Spring项目搭建","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:42:11.281Z","comments":true,"path":"2020/02/20/Spring/【Spring】0. Spring项目搭建/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Spring/%E3%80%90Spring%E3%80%910.%20Spring%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","excerpt":"第一次使用idea搭建Spring项目的小伙伴可能都会碰到各种的问题，而我自己也是碰到各种问题，所以决定写个博客巩固下，方便以后使用，好了闲话就不多说了。","text":"第一次使用idea搭建Spring项目的小伙伴可能都会碰到各种的问题，而我自己也是碰到各种问题，所以决定写个博客巩固下，方便以后使用，好了闲话就不多说了。 0. Spring项目搭建​ 第一次使用idea搭建Spring项目的小伙伴可能都会碰到各种的问题，而我自己也是碰到各种问题，所以决定写个博客巩固下，方便以后使用，好了闲话就不多说了。​ 首先得做个准备工作（电脑里得提前安装好idea和maven），项目所使用的jar包都是使用maven自动导入，所以没有下载安装maven的童鞋还得下载安装一个maven。 0.0 前期准备​ 打开Idea选择 File 》New 》Project… ，选择Maven，勾选Create from arcetype，找到org.apache.maven.archetype:maven-archetype-webapp 选中，点击Next按钮。 pom.xml中添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yihang.ml/categories/Spring/"}],"tags":[]},{"title":"1. Spring的体系结构","slug":"Spring/【Spring】1. Spring的体系结构","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:42:34.352Z","comments":true,"path":"2020/02/20/Spring/【Spring】1. Spring的体系结构/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Spring/%E3%80%90Spring%E3%80%911.%20Spring%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"Spring是一个轻量级Java开发框架，最早由Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的偶合问题。它是一个分层的JavaSE/EE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。","text":"Spring是一个轻量级Java开发框架，最早由Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的偶合问题。它是一个分层的JavaSE/EE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 1. Spring的体系结构​ Spring是一个轻量级Java开发框架，最早由Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的偶合问题。它是一个分层的JavaSE/EE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 1.1 Spring的体系结构​ Spring框架至今已经集成了20多个模块，这些模块分布在核心容器（Core Container）、数据访问/集成（Data Access/Integration）层、Web层、AOP层（Aspect Oriented Programming，面向切面的编程）模块、植入（Instrumentation）模块、消息传播（Messaging）和测试（Test）模块中，如下图所示： 1. 1.1 核心容器 Spring-core模块：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IoC）和依赖注入（Dependency Injection，DI）功能。 Spring-beans模块：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象成为Bean。 Spring-context模块：建立在Core和Beans模块的基础之上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext接口是Context模块的焦点。 Spring-context-support模块：支持整合第三方库到Spring应用程序上下文，特别是用于高速缓存（EhCache、JCache）和任务调度（CommonJ、Quartz）的支持。 Spring-expression模块：提供了强大的表达式语言去支持运行时查询和操作对象图。这是JSP2.1规范中规定的同意表达式语言（Unified EL）的扩展。该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算数运算、变量命名以及从Spring的IoC容器中以名称检索对象。它还支持列表投影、选择以及常见的列表聚合。 1.1.2 AOP和Instrumentation Spring-aop模块：提供了一个符合AOP要求的面向切面的编程实现，允许定义方法 拦截器和切入点，将代码按照功能进行分离，以便干净地解耦。 Spring-aspects模块：提供了与AspectJ的集成功能，AspectJ是一个功能强大且成熟的AOP框架。 Spring-instrument模块：提供了类植入（Instrumentation）支持和类加载器的实现，可以在特定的应用服务器中使用。 1.1.3 消息Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。 1.1.4 数据访问/集成输入访问/集成层由JDBC、ORM、OXM、JMS和事务模块组成。 Spring-jdbc模块：提供了一个JDBC的抽象层，消除了繁琐的JDBC编码和数据厂商特有的错误代码解析。 Spring-orm模块：为流行的对象关系映射（Object-Relational Mapping）API提供集成层，包括JPA和Hibernate。使用Spring-rom模块可以将这些O/R映射框架与Spring提供的所有其他功能结合使用，例如声明式事物管理功能。 Spring-oxm模块：提供了一个支持对象/XML映射的抽象层实现，例如JAXB、Castor、JiBX和XStream。 Spring-jms模块（Java Messaging Service）：指Java消息传递服务，包含用于生产和使用消息的功能。自Spring4.1以后，提供了Spring-messaging模块的集成。 Spring-tx模块（事物模块）：支持用于实现特殊接口和所有POJO（普通Java对象）类的编程和声明式事务管理。 1.1.5 WebWeb层由Spring-Web、Spring-webmvc、Spring-websocket和Portlet模块组成。 Spring-web模块：提供了基本的Web开发集成功能，例如多文件上传功能、使用Servlet监听器初始化一个IoC容器以及Web应用上下文。 Spring-webmvc模块：也称为Web-Servlet模块，包含用于Web应用程序的Spring MVC和REST Web Services实现。Spring MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与Spring Frameword的所有其他功能集成。 Spring-websocket模块：Spring 4.0 以后新增的模块，它提供了WebSocket和SockJS的实现。 Portlet模块：类似于Servlet模块的功能，提供了Portlet环境下的MVC实现。 1.1.6 测试Spring-test模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。 1.2 Spring的目录结构1.2.1 Spring的Jar包下载到的Spring framework ZIP文件解压缩后的目录结构如图所示： docs目录包含Spring的API文档和开发规范； libs目录包含开发Spring应用所需要的Jar包和源代码； 3类JAR文件： 以RELEASE.jar结尾的文件是Spring框架class的JAR包，即开发Spring应用所需要的JAR包； 以RELEASE-javadoc.jar结尾的文件是Spring框架API文档的压缩包； 以RELEASE-sources.jar结尾的文件是Spring框架源文件的压缩包。 4个基础包： spring-core-x.x.x.RELEASE.jar ——（Spring-core 模块） spring-beans-x.x.x.RELEASE.jar —— （Spring-beans模块） spring-context-x.x.x.RELEASE.jar —— （Spring-context模块） spring-expression-x.x.x.RELEASE.jar —— （Spring-expression模块） schema目录包含开发Spring应用所需要的schema文件，这些schema文件定义了Spring相关配置文件的约束。 1.2.2 commons.logging的JAR包​ Spring框架依赖于Apache Commons Logging组件，该组件的JAR包可以通过网址“http://commons.apache.org/proper/commons-logging/download_logging.cgi”下载。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yihang.ml/categories/Spring/"}],"tags":[]},{"title":"Jsp技术","slug":"Servlet、Jsp/【Servlet-Jsp】Jsp技术","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:38:04.379Z","comments":true,"path":"2020/02/20/Servlet、Jsp/【Servlet-Jsp】Jsp技术/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Servlet%E3%80%81Jsp/%E3%80%90Servlet-Jsp%E3%80%91Jsp%E6%8A%80%E6%9C%AF/","excerpt":"Jsp技术 Jsp 概述 Jsp：Java Server Page Jsp 程序是在传统的HTML文档中插入Java程序段或Jsp标签而形成。(*.jsp)Jsp技术","text":"Jsp技术 Jsp 概述 Jsp：Java Server Page Jsp 程序是在传统的HTML文档中插入Java程序段或Jsp标签而形成。(*.jsp)Jsp技术 Jsp技术1. Jsp 概述 Jsp：Java Server Page Jsp 程序是在传统的HTML文档中插入Java程序段或Jsp标签而形成。(*.jsp) Jsp 是一种实现静态和动态混合编码的技术。 12345678910111213141516&lt;%@ page language=\"java\" import=\"java.util.*\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;body&gt; &lt;% Date d=new Date(); int h=d.getHours(); if(h&gt;12) out.print(\"下午好\"); else out.print(\"上午好\"); %&gt;&lt;/body&gt;&lt;body&gt; &lt;% for(int i=0; i&lt;5; i++) &#123; %&gt; &lt;!-- Jsp表达式 --&gt; &lt;div style=\"font-size:&lt;%=20+i%&gt;px\"&gt;测试JSP&lt;/div&gt; &lt;% &#125; %&gt;&lt;/body&gt; * Jsp 执行过程Jsp页面中的HTML标记(静态部分)交给客户端浏览器直接显示。 服务器端执行&lt;%和%&gt;之间的Java程序(动态部分)，并把执行结果交给客户端的浏览器显示。 服务器端还要负责处理相关的Jsp标记，并将有关的处理结果发送到客户的浏览器。 2. Jsp 脚本元素2.1 HTML注释 ** ** 客户端可见 2.2 隐藏的注释&lt;%– 注释语句 –%&gt; 客户端不可见 12345678&lt;%-- 张三编写 日期： 2016.3 --%&gt;&lt;script&gt; function clickme()&#123; alert(\"你敢点我!\"); // js 注释 &#125;&lt;/script&gt;&lt;!-- 欢迎页面 --&gt;&lt;p onclick=\"clickme()\" style=\"cursor: pointer\"&gt;点击我&lt;/p&gt; 2.3 输出表达式 &lt;%= 表达式 %&gt; 12&lt;% String s=\"abcde\"; %&gt;字符串s= &lt;%=s%&gt;，长度= &lt;%= s.length()%&gt; 2.4 全局变量声明&lt;%! 变量声明; [声明; ] … %&gt; 12345&lt;body&gt; &lt;% i++; %&gt; &lt;p&gt;您是第&lt;%=i%&gt;个访问本站的客户&lt;/p&gt; &lt;%! int i=0; %&gt;&lt;/body&gt; 2.5 方法声明 &lt;%! 方法代码 %&gt; 1234567&lt;body&gt; &lt;%! int add(int a,int b) &#123; return a+b; &#125; %&gt; 1+2=&lt;%= add(1,2) %&gt;&lt;/body&gt; 2.6 类声明 &lt;%! 类代码 %&gt; 1234567891011&lt;body&gt; &lt;%! class GF &#123; String XM; int AGE; GF(String xm, int a) &#123; XM=xm; AGE=a; &#125; String getXM() &#123; return XM; &#125; &#125; %&gt; &lt;%GF a=new GF(\"小明\",20);%&gt; &lt;%=a.getXM() %&gt;&lt;/body&gt; 3. Jsp动作组件 &lt; jsp:include&gt;：在页面中包含一个文件。 &lt; jsp:forward&gt;：把请求转发到另一个新的页面。 &lt; jsp:param&gt;：在动作组件中引入参数信息。 &lt; jsp:useBean&gt;：寻找或者实例化一个JavaBean。 【JavaBean中使用】 &lt; jsp:setProperty&gt;：设置JavaBean的属性。【JavaBean中使用】 &lt; jsp:getProperty&gt;：输出某个JavaBean的属性。【JavaBean中使用】 3.1 jsp:include语法格式： 1234567&lt;jsp:include page=\"relativeURL\"/&gt;或 &lt;jsp:include page=\"relativeURL\"&gt; &lt;jsp:param name=\"参数1\" value=\"参数1值\"/&gt; … &lt;jsp:param name=\"参数n\" value=\"参数n值\"/&gt; &lt;/jsp:include&gt; 3.2 &lt; jsp:forward&gt;语法格式： 1234567&lt; jsp:forward page=\"relativeURL\"/&gt;或 &lt; jsp:forward page=\"relativeURL\"&gt; &lt;jsp:param name=“参数1” value=“参数1值”/&gt; … &lt;jsp:param name=“参数n” value=“参数n值”/&gt; &lt;/jsp:include&gt; 3.3 &lt; jsp:param&gt; 用于传递参数信息，必须配合&lt; jsp:include&gt;或&lt; jsp:forward&gt;动作组件一起使用。 语法格式： 1&lt;jsp:param name=“参数” value=“参数值”/&gt; 4. Jsp内置对象4.1 request对象 request对象中封装了客户端发送过来的所有的请求数据（包括请求头信息，请求方式，客户端ip地址以及请求参数等）。 request对象的作用域为一次请求。 4.2 response对象 response对象代表服务器对客户端请求的响应。 基本用法： 123void setHeader(String name, String value) void sendRedirect(String location) 4.2.1 response.setHeader()方法 用法1：设置页面自动刷新 1response.setHeader(\"refresh\", \"秒数\"); 用法2：设置定时跳转页面 1response.setHeader(\"refresh\", \"秒数 **;** URL=页面名称\") ; 4.2.2 response.sendRedirect()方法 用法1：请求重定向到新页面（页面跳转） 1response.sendRedirect(\"http://www.wust.edu.cn\"); 用法2：跳转时传递数据 1response.sendRedirect(\"edit.jsp?id=1\"); 4.2.3 redirect和forward方式区别 jsp:forward response.sendRedirect**()** 效率高，速度快 效率低，速度慢 地址栏不改变跳转，服务器端跳转，服务器之间内部转 地址栏改变跳转，客户端跳转（其中地址可以是任意的） 使用forward时，相同的request，依然能保留在下一个页面 客户端跳转，不同的request 传递参数： &lt;jsp:param name=” “ value=” “ /&gt; URL传递参数：response.sendRedirect(“test.jsp?id=1234”) 无条件立刻跳转，之后的代码不再被执行 所有代码执行完毕之后再跳转 地址中的”/“代表网站地址，如: http://localhost:8080/Test 地址中的”/“代表服务器地址: http://localhost:8080/ 4.3 session对象 session代表服务器与客户端所建立的会话。 从一个客户端打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。 当一个客户首次访问服务器上页面时，服务器将产生一个session对象，同时分配一个String类型的id号。 session可以实现在一个会话期间的多页面间的数据共享/传递。 4.3.1 session基本用法 session.setAtrribute(String name, Object value) 用value来初始化session对象某个属性(name指定)的值; 如果指定的属性不存在，则新建一个；如果已存在，则更改name属性的值。 session.getAtrribute(String name) 获得由name指定名称的session对象属性的值; 方法返回Object对象，因此，对返回的对象要用强制转换把得到的对象转换为此对象原来的类型; 如果属性不存在，返回空值。 4.4 application对象 Web服务器一旦启动，就会自动创建application对象，并一直保持，直到服务器关闭。 application对象负责提供应用程序在服务器中运行时的一些全局信息，客户端使用的application对象都是一样的。 在此期间，在任何地方对application对象相关属性的操作，都将影响到其他用户对此的访问。 application对象可以实现用户间数据的共享/传递。 4.4.1 application基本用法 application.setAttribute(String name, Object value) 用value来初始化application对象某个属性(name指定)的值; 如果指定的属性不存在，则新建一个；如果已存在，则更改name属性的值。 application.getAttribute(String name) 获得由name指定名称的application对象属性的值; 方法返回Object对象，因此，对返回的对象要用强制转换把得到的对象转换为此对象原来的类型; 如果属性不存在，返回空值。 4.5 out对象 out对象用来向客户端发送数据(文本级)，其内容将是浏览器需要显示的内容。 常用方法：pirnt()","categories":[{"name":"Servlet、Jsp","slug":"Servlet、Jsp","permalink":"https://www.yihang.ml/categories/Servlet%E3%80%81Jsp/"}],"tags":[]},{"title":"4. Spring AOP","slug":"Spring/【Spring】4. Spring AOP","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:43:54.077Z","comments":true,"path":"2020/02/20/Spring/【Spring】4. Spring AOP/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Spring/%E3%80%90Spring%E3%80%914.%20Spring%20AOP/","excerpt":"AOP ( Aspect-Oriented Programming ）即面向切面编程，它与OOP (Object-Oriented Programming ， 面向对象编程） 相辅相成，提供了与OOP 不同的抽象软件结构的视角。","text":"AOP ( Aspect-Oriented Programming ）即面向切面编程，它与OOP (Object-Oriented Programming ， 面向对象编程） 相辅相成，提供了与OOP 不同的抽象软件结构的视角。 4. Spring AOP4.1 Spring AOP的基本概念4.1.1 AOP的概念​ AOP ( Aspect-Oriented Programming ）即面向切面编程，它与OOP (Object-Oriented Programming ， 面向对象编程） 相辅相成，提供了与OOP 不同的抽象软件结构的视角。在OOP 中，以类作为程序的基本单元，而AOP 中的基本单元是Aspect （切面）。Struts2的拦截器设计就是基于AOP 的思想，是个比较经典的应用。 4.1.2 AOP的术语 切面切面（Aspect）是指封装横切到系统功能（例如事务处理）的类。 连接点连接点（Joinpoint）是指程序运行中的一些时间点，例如方法的调用或异常的抛出。 切人点切入点（Pointcut）是指需要处理的连接点。在Spring AOP 中，所有的方法执行都是连接点，而切入点是一个描述信息，它修饰的是连接点，通过切入点确定哪些连接点需要被处理。 通知通知（Advice）是由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要执行的程序代码，可以将其理解为切面开启后切面的方法，因此通知是切面的具体实现。 引人引入（Introduction）允许在现有的实现类中添加自定义的方法和属性。 目标对象目标对象（Target Object）是指所有被通知的对象。如果AOP 框架使用运行时代理的方式（动态的AOP ）来实现切面，那么通知对象总是一个代理对象。 代理代理（Proxy）是通知应用到目标对象之后被动态创建的对象。 织人织入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。根据不同的实现技术， AOP 织入有3 种方式：编译期织入， 需要有特殊的Java 编译器；类装载期织入， 需要有特殊的类装载器；动态代理织入，在运行期为目标类添加通知生成子类的方式。SpringAOP 框架默认采用动态代理织入，而AspectJ（基于Java 语言的AOP 框架）采用编译期织入和类装载期织入。 4.2 动态代理​ 在Java中有多种动态代理技术，例如JDK、CGLIB、Javassist、ASM，其中最常用的动态代理技术是JDK和CGLIB。目前，在Spring AOP中常用JDK和CGLIB两种动态代理技术。 4.2.1 JDK动态代理​ JDK 动态代理是java.lang . reflect. ＊包提供的方式，它必须借助一个接口才能产生代理对象。因此，对于使用业务接口的类， Spring 默认使用JDK 动态代理实现AOP 。 实例演示： 创建应用，创建接口及实现类，在src的目录下创建一个dynamic.jdk包，在该包中创建接口TestDao和接口实现类TestDaoImpl。该实现类作为目标类，在代理类中对其方法进行增强处理。 TestDao的代码如下： 1234567package dynamic.jdk;public interface TestDao &#123; public void save(); public void modify(); public void delete();&#125; TestDaoImpl的代码如下： 123456789101112131415161718package dynamic.jdk;public class TestDaoImpl implements TestDao &#123; @Override public void save() &#123; System.out.println(\"保存\"); &#125; @Override public void modify() &#123; System.out.println(\"修改\"); &#125; @Override public void delete() &#123; System.out.println(\"删除\"); &#125;&#125; 创建切面类 在src目录下创建一个aspect包，在该包下创建切面类MyAspect，注意在该类中可以定义多个通知（增强处理的功能方法）。 MyAspect的代码如下： 12345678910111213141516171819202122package aspect;/** * 切面类，可以定义多个通知，即增强处理的方法 */public class MyAspect &#123; public void check() &#123; System.out.println(\"模拟权限控制\"); &#125; public void except() &#123; System.out.println(\"模拟一场处理\"); &#125; public void log() &#123; System.out.println(\"模拟日志记录\"); &#125; public void monitor() &#123; System.out.println(\"性能检测\"); &#125;&#125; 创建代理类 在dynamic.jdk包中创建代理类JDKDynamicProxy。在JDK动态代理中代理类必须实现java.lang.reflect.InvocationHandler接口，并编写代理方法，在代理方法中需要通过Proxy实现动态代理。 JDKDynamicProxy的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package dynamic.jdk;import aspect.MyAspect;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class JDKDynamicProxy implements InvocationHandler &#123;// 声明目标类接口对象（真实对象） private TestDao testDao;// 创建代理的方法，建立代理对象和真实对象的代理关系，并返回代理对象 public Object createProxy(TestDao testDao) &#123; this.testDao = testDao;// 1. 类加载器 ClassLoader cld = JDKDynamicProxy.class.getClassLoader();// 2. 被代理对象实现的所有接口 Class[] clazz = testDao.getClass().getInterfaces();// 3. 使用代理类进行增强，返回代理后的对象 return Proxy.newProxyInstance(cld, clazz, this); &#125; /** * 代理的逻辑方法，所有动态代理类的方法调用都交给该方法处理 * proxy是被代理对象 * method是将要被执行的方法 * args是执行方法时需要的参数 * return指返回代理结果 * * @param proxy * @param method * @param args * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// 创建一个切面 MyAspect myAspect = new MyAspect();// 前增强 myAspect.check(); myAspect.except();// 在目标类上调用方法标并传入参数，相当于调用testDao中的方法 Object obj = method.invoke(testDao, args);// 后增强 myAspect.log(); myAspect.monitor(); return obj; &#125;&#125; 创建测试类 在dynamic.jdk包中创建测试类JDKDynamicTest。在主方法中创建代理对象和目标对象，然后从代理对象中获取对目标对象增强后的对象，最后调用该对象的添加、修改和删除方法。 JDKDynamicTest的代码如下： 123456789101112131415161718package dynamic.jdk;public class JDKDynamicTest &#123; public static void main(String[] args) &#123;// 创建代理对象 JDKDynamicProxy jdkProxy = new JDKDynamicProxy();// 创建目标对象 TestDao testDao = new TestDaoImpl();// 从代理对象中获取增强后的目标对象，该对象是一个被代理的对象，它会进入代理的逻辑方法invoke中 TestDao testDaoAdvice = (TestDao) jdkProxy.createProxy(testDao);// 执行方法 testDaoAdvice.save(); System.out.println(\"===============\"); testDaoAdvice.modify(); System.out.println(\"===============\"); testDaoAdvice.delete(); &#125;&#125; 运行效果： 4.2.2 CGLIB动态代理​ JDK 动态代理必须提供接口才能使用，对于没有提供接口的类，只能采用CGLIB 动态代理。 ​ CGLIB (Code Generation Library ） 是一个高性能开源的代码生成包，采用非常底层的字节码技术，对指定的目标类生成一个子类，并对子类进行增强。在Spring Core 包中己经集成了CGLIB 所需要的JAR 包，不需要另外导入JAR 包。 实例演示： 创建目标类 在src目录下创建一个dynamic.cglib包，在该包中创建目标类TestDao，注意该类不需要实现任何接口。 TestDao的代码如下： 1package dynamic.cglib; public class TestDao { public void save() { System.out.println(“保存”); } public void modify() { System.out.println(&quot;修改&quot;); } public void delete() { System.out.println(&quot;删除&quot;); } } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 - 创建代理类 在dynamic.cglib包中创建代理类CglibDynamicProxy，该类实现MethodInterceptor接口。 CglibDynamicProxy的代码如下： &#96;&#96;&#96;java package dynamic.cglib; import org.aopalliance.intercept.MethodInterceptor; import org.aopalliance.intercept.MethodInvocation; import org.springframework.cglib.proxy.Callback; import org.springframework.cglib.proxy.Enhancer; import org.springframework.cglib.proxy.MethodProxy; import java.lang.reflect.Method; &#x2F;** * @Author: yihangjou(周逸航) * @Site: www.yihang.ml * @cnBlogs: https:&#x2F;&#x2F;www.cnblogs.com&#x2F;yihangjou&#x2F; * @Date: create in 2020&#x2F;2&#x2F;16 14:54 *&#x2F; public class CglibDynamicProxy implements MethodInterceptor &#123; &#x2F;** * 创建代理的方法，生成CGLIB代理对象 * target是目标对象，需要增强的对象 * 返回目标对象的CGLIB代理对象 *&#x2F; public Object createProxy(Object target) &#123; &#x2F;&#x2F; 创建一个动态类对象，即增强类对象 Enhancer enhancer &#x3D; new Enhancer(); &#x2F;&#x2F; 确定需要增强的类，设置其父类 enhancer.setSuperclass(target.getClass()); &#x2F;&#x2F; 确定代理逻辑对象为当前对象，要求当前对象实现MethodIntercepor的方法 enhancer.setCallback((Callback) this); &#x2F;&#x2F; 返回创建的代理对象 return enhancer.create(); &#125; &#x2F;** * intercept方法会在程序执行目标方法时被调用 * proxy时CGLIB根据指定父类生成的代理对象 * method是拦截方法 * args是拦截方法的参数数组 * methodProxy是方法的代理对象，用于执行父类的方法 * 返回代理结果 *&#x2F; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; &#x2F;&#x2F;创建一个切面 MyAspect myAspect &#x3D; new MyAspect(); &#x2F;&#x2F;前增强 myAspect.check(); myAspect.except(); &#x2F;&#x2F;目标方法执行，返回代理结果 Object obj &#x3D; methodProxy.invokeSuper(proxy, args); &#x2F;&#x2F;后增强 myAspect.log(); myAspect.monitor(); return obj; &#125; @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; return null; &#125; &#125; 创建测试类 在dynamic.cglib包中创建测试类CglibDynamicTest。在主方法中创建代理对象和目标对象，然后从代理对象中获取对目标对象增强后的对象，最后调用该对象的添加、修改和删除方法。 CglibDynamicTest的代码如下： 123456789101112131415161718192021222324package dynamic.cglib;/** * @Author: yihangjou(周逸航) * @Site: www.yihang.ml * @cnBlogs: https://www.cnblogs.com/yihangjou/ * @Date: create in 2020/2/16 15:00 */public class CglibDynamicTest &#123; public static void main(String[] args) &#123; //创建代理对象 CglibDynamicProxy cdp = new CglibDynamicProxy(); //创建目标对象 TestDao testDao = new TestDao(); //获取增强后的目标对象 TestDao testDaoAdvice = (TestDao)cdp.createProxy(testDao); //执行方法 testDaoAdvice.save(); System.out.println(\"=============\"); testDaoAdvice.modify(); System.out.println(\"=============\"); testDaoAdvice.delete(); &#125;&#125; 运行效果与JDK动态代理运行效果相同。 4.3 基于代理类的AOP实现​ 在Spring中默认使用JDK动态代理实现AOP编程。使用org.springframework.aop.framwork.ProxyFactoryBean创建代理是Spring AOP实现的最基本方式。 4.3.1 通知类型根据Spring中通知在目标类方法中的连接点位置，通知可以分为6种类型。 4.3.1.1 环绕通知​ 环绕通知（org.aopallicance.intercept.MethodIntercerptor）是在目标方法执行前和执行后实施增强，可应用于日志记录、事务处理等功能。 4.3.1.2 前置通知​ 前置通知（org.springframework.aop.MethodBeforeAdvice）实在目标方法执行前实施增强，可应用于权限管理等功能。 4.3.1.3 后置返回通知​ 后置返回通知（org.springframework.aop.AfterReturningAdvice）是在目标方法成功执行后实施增强，可应用于关闭流、删除临时文件等功能。 4.1.3.5 后置（最终）通知​ 后置通知（org.springframework.aop.AfterAdvice）是在目标方法执行后实施增强，与后置返回通知不同的是，不管是否发生异常都要执行该类通知，该类通知可应用于释放资源。 4.1.3.6 引入通知​ 引入通知（org.springframework.aop.IntroductionInterceptor）是在目标类中添加一些新的方法和属性，可应用于修改目标类（增强类）。 4.3.2 ProxyFactoryBean​ ProxyFactoryBean是org.springframework.beans.factory.FactoryBean接口的实现类，FactoryBean负责实例化一个Bean实例，ProxyFactoryBean负责为其他Bean实例创建代理实例。 * ProxyFactoryBean类的常用属性： 4.4 基于XML配置开发AspectJ​ AspectJ是一个基于Java语言的AOP框架。使用AspectJ实现Spring AOP的方式有两种，一是基于XML配置开发AspectJ，二是基于注解开发AspectJ。 ​ 基于XML配置开发AspectJ是指通过XML配置文件定义切面、切入点及通知，所有这些定义都必须在&lt;aop:config&gt;元素内。&lt;aop:config&gt;元素及其子元素如下表所示： ​ 各类型通知与目标方法的执行过程，具体过程如图所示： 案例演示： 创建切面类 在src目录下创建aspectj.xml包，在该包下创建切面类MyAspect。 MyAspect的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package aspectj.xml;/** * @Author: yihangjou(周逸航) * @Site: www.yihang.ml * @cnBlogs: https://www.cnblogs.com/yihangjou/ * @Date: create in 2020/2/17 11:30 */import org.aopalliance.intercept.Joinpoint;import org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint;/** * 切面类，在此类中编写各种类型的通知 */public class MyAspect &#123; /** * 前置通知，使用JoinPoint接口作为参数获得目标对象信息 */ public void before(Joinpoint jp) &#123; System.out.print(\"前置通知：模拟权限控制\"); System.out.println(\",目标类对象：\" + jp.getTarget() + \",被增强处理的方法：\" + jp.getSignature().getName()); &#125; /** * 后置返回通知 */ public void afterReturning(Joinpoint jp) &#123; System.out.print(\"后置返回通知：\" + \"模拟删除临时文件\"); System.out.println(\", 被增强处理的方法：\" + jp.getSignature().getName()); /** * 环绕通知 * ProceedingJoinPoint是JoinPoint的子接口，代表可以执行的目标方法 * 返回值的类型必须是Object * 必须一个参数是ProceedingJoinPoint类型 * 必须throws Throwable */ public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; //开始 System.out.println(\"环绕开始：执行目标方法前，模拟开启事务\"); //执行当前目标方法 Object obj = pjp.proceed(); //结束 System.out.println(\"环绕结束：执行目标方法后，模拟关闭事务\"); return obj; &#125; /** * 异常通知 */ public void except(Throwable e) &#123; System.out.println(\"异常通知：\" + \"程序执行异常\" + e.getMessage()); &#125; /** * 后置（最终）通知 */ public void after() &#123; System.out.println(\"最终通知：模拟释放资源\"); &#125; &#125;&#125; 创建配合文件，并编写相关配置，在aspectj.xml包中创建配置文件applicationContext.xml，并为&lt;aop: config&gt;元素及其子元素编写相关配置。 applicationContext.xml的代码如下： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- 定义目标对象，使用实现类--&gt; &lt;bean id=\"testDao\" class=\"dynamic.jdk.TestDaoImpl\" /&gt;&lt;!-- 创建一个切面--&gt; &lt;bean id=\"myAspect\" class=\"aspectj.xml.MyAspect\" /&gt;&lt;!-- 使用Spring代理工厂定义一个名为testDaoProxy的代理对象--&gt; &lt;bean id=\"testDaoProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt;&lt;!-- 指定代理实现的接口--&gt; &lt;property name=\"proxyInterfaces\" value=\"dynamic.jdk.TestDao\" /&gt;&lt;!-- 指定目标对象--&gt; &lt;property name=\"target\" ref=\"testDao\" /&gt;&lt;!-- 指定切面，织入环绕通知--&gt; &lt;property name=\"interceptorNames\" value=\"myAspect\" /&gt; 指定代理方式，true指定CGLIB动态代理；默认为false，指定JDK动态代理 &lt;property name=\"proxyTargetClass\" value=\"true\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试类 在aspectj.xml包中创建测试类XMLAspectJTest，在主方法中使用Spring容器获取代理对象，并执行目标方法。 XMLAspectJTest的代码如下： 12345678910111213141516171819202122232425package spring.proxyfactorybean;import dynamic.jdk.TestDao;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @Author: yihangjou(周逸航) * @Site: www.yihang.ml * @cnBlogs: https://www.cnblogs.com/yihangjou/ * @Date: create in 2020/2/17 13:23 */public class ProxyFactoryBeanTest &#123; public static void main(String[] args) &#123; ApplicationContext appCon = new ClassPathXmlApplicationContext(\"/spring/proxyfactorybean/applicationContext.xml\");// 从容器中获取增强后的目标对象 TestDao testDaoAdvice = (TestDao)appCon.getBean(\"testDaoProxy\");// 执行方法 testDaoAdvice.save(); System.out.println(\"========================\"); testDaoAdvice.modify(); System.out.println(\"========================\"); testDaoAdvice.delete(); &#125;&#125; 运行效果 4.5 基于注解开发AspectJ​ 基于注解开发AspectJ要比基于XML配置开发AspectJ便捷许多，所以在实际开发中推荐使用注解方法。 ​ AspectJ注解，如下表所示： 案例演示： 创建切面类 在src目录下创建aspectj.annotation包，在该包中创建切面类MyAspect。在该类中首先使用@Aspect注解定义一个切面类，由于该类在Spring中是作为组件使用的，所以还需要使用@Component注解；然后使用@Pointcut注解切入点表达式，并通过定义方法来表示切入点名称；最后再每个通知方法上添加相应的注解，并将切入点名称作为参数传递给需要执行增强的通知方法。 MyAspect的代码如下： 1 注解目标类 使用注解@Repository将目标类dynamic.jdk.TestDaoImpl注解为目标对象，注解代码如下： 1 创建配置文件 在aspectj.annotation包中创建配置文件applicationContext.xml，并在配置文件中指定需要扫描的包，使注解生效，同时需要启动基于注解的AspectJ的支持。 applicationContext.xml的代码如下： 1 创建测试类 测试类的运行结果与XML配置结果相同。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yihang.ml/categories/Spring/"}],"tags":[]},{"title":"2. Spring IoC","slug":"Spring/【Spring】2. Spring IoC","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:43:01.636Z","comments":true,"path":"2020/02/20/Spring/【Spring】2. Spring IoC/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Spring/%E3%80%90Spring%E3%80%912.%20Spring%20IoC/","excerpt":"控制反转（Inversion of Control，IoC）是Spring框架的核心，用来消减计算机程序的偶合问题。 依赖注入（Dependency Injection，DI）是IoC的另外一种说法，只是从不同的角度描述相同的概念。","text":"控制反转（Inversion of Control，IoC）是Spring框架的核心，用来消减计算机程序的偶合问题。 依赖注入（Dependency Injection，DI）是IoC的另外一种说法，只是从不同的角度描述相同的概念。 2. Spring IoC2.1 Spring IoC的基本概念控制反转（Inversion of Control，IoC）是Spring框架的核心，用来消减计算机程序的偶合问题。 依赖注入（Dependency Injection，DI）是IoC的另外一种说法，只是从不同的角度描述相同的概念。 ​ 当Spring框架出现后，对象的实例不再由调用者来创建，而是由Spring容器来创建。Spring容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制。这样，控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转。 ​ 从Spring容器角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，相当于为调用者注入它所依赖的实例，这就是Spring的依赖注入。 ​ 综上所述，控制反转是一种通过描述（在Spring中可以是XML或注解）并通过第三方去产生或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入。 2.2 Spring IoC容器2.2.1 BeanFactory​ BeanFactory由org.springframework.beans.factory.BeanFactory接口定义，他提供了完整的IoC服务支持，是一个管理Bean的工厂，主要负责初始化各种Bean。BeanFactory接口有多个实现类，其中比较常用的是org.springframework.beans.factory.xml.XmlBeanFactory。 ​ 在创建BeanFactory实例时需要提供XML文件的绝对路径。下面是main方法中的一个示例代码： 12345678910public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 BeanFactory beanFac = new XmlBeanFactory( new FileSystemResource(\"D:\\eclipse-workspace\\ch1\\src\\ applicationContext.xml\") ); //通过容器获取test实例 TestDao tt = (TestDao)beanFac.getBean(\"test\"); tt.sayHello();&#125; 2.2.2 ApplicationContext​ ApplicationContext是BeanFactory的子接口，也称为应用上下文，由org.springframework.context.ApplicationContext接口定义。ApplicationContext接口除了包含BeanFactory的所有功能以外，还添加了对国际化、资源访问、事件传播等内容的支持。 ​ 创建ApplicationContext接口实例通常有一下3种方法： 通过ClassPathXmlApplicationContext创建 ClassPathXmlApplicationContext将从类路径目录（src根目录）中寻找指定的XML配置文件。代码如下： 1234567public static void mian(String[] args) &#123; //初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext appCon = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //通过容器获取test实例 TestDao tt = new (TestDao)appCon.getBean(\"test\"); tt.sayHello();&#125; 通过FileSystemXmlApplicationContext创建 FileSystemXmlApplicationContext将从指定文件的绝对路径中寻找XML配置文件，找到并装载完成ApplicationContext的实例化工作。代码如下： 1234567public static void mian(String[] args) &#123; //初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext appCon = new FileSystemXmlApplicationContext(\"D:\\eclipse-workspace\\ch1\\src\\applicationContext.xml\"); //通过容器获取test实例 TestDao tt = new (TestDao)appCon.getBean(\"test\"); tt.sayHello();&#125; 采用绝对路径的加载方式将导致程序的灵活性变差，一般不推荐使用。因此块，通常在Spring的Java应用中采取通过ClassPathXmlApplicationContext类来实例化ApplicationContext容器的方式，而在Web应用中，ApplicationContext容器的实例化工作将交给Web服务器完成。 通过Web服务器实例化ApplicationContext容器 在Web服务器实例化ApplicationContext容器时，一般使用基于org.framework.web.context.ContextLoaderListener的实现方式（需要将spring-web-x.x.x.RELEASE.jar复制到WEB-INF/lib目录中），此方法只需在web.xml中添加如下代码： 12345678910111213&lt;context-param&gt; &lt;!-- 加载src目录下的applicationContext.xml文件 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 指定以ContextLoaderListener方式启动Spring容器 --&gt;&lt;listener&gt; &lt;listener-class&gt; org.framework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 2.3 依赖注入的类型​ 在Spring中实现IoC容器的方法是依赖注入，依赖注入的作用是在使用Spring框架创建对象时动态地将其所依赖的对象（例如属性值）注入Bean组件中。Spring框架的依赖注入通常有两种实现方式，一种是使用构造方法注入，另一种是使用属性的setter方法注入。 2.3.1 使用构造方法注入​ Spring框架可以采用Java的反射机制，通过构造方法完成依赖注入。 实例讲解： 创建dao包 创建dao包在service中使用构造方法依赖注入TestDIDao接口对象。 TestDIDao接口代码如下： 1234package dao;public interface TestDIDao &#123; public void sayHello();&#125; TestDIDaoImpl实现类代码如下： 1234567package dao;public class TestDIDaoImpl implements TestDIDao &#123; @Override public void sayHello() &#123; system.out.println(\"TestDIDao say: Hello, Study hard!\"); &#125;&#125; 创建service包 在TestDIServiceImpl中使用构造方法依赖注入TestDIDao接口对象。 TestDIService接口代码如下： 1234package service;public interface TestDIService &#123; public void sayHello();&#125; TestDIServiceImpl实现类代码如下： 1234567891011121314151617package service;import dao.TestDIDao;public class TestDIServiceImlp implements TestDIService &#123; private TestDIDao testDIDao; //构造方法,用于实现依赖注入接口对象testDIDao public TestDIServiceImpl(TestDIDao testDIDao) &#123; super(); this.testDIDao = testDIDao; &#125; @Override public void sayHello() &#123; //调用testDIDao中的sayHello方法 testDIDao.sayHello(); System.out.println(\"TestDIService构造方法注入say: Hello, Study hard!\"); &#125;&#125; 编写配置文件 在src根目录下根目录下创建Spring配置文件applicationContext.xml。在配置文件中首先将dao.TestDIDaoImpl类托管给Spring，让Spring创建其对象，然后将service.TestDIServiceImpl类托管给Spring，让Spring创建其对象，同时给构造方法传递实参。配置文件代码如下： 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 模拟spring执行过程 创建service实例：BookService bookService = new BookServiceImpl() IoC &lt;bean&gt; 创建dao实例：BookDao bookDao = new BookDaoImpl() IoC 将dao设置给service：bookService.setBookDao(bookDao); DI &lt;property&gt; &lt;property&gt; 用于进行属性注入 name： bean的属性名，通过setter方法获得 setBookDao ##&gt; BookDao ##&gt; bookDao ref ：另一个bean的id值的引用 --&gt; &lt;!-- 将指定类TestDIDaoImpl配置给Spring，让Spring创建其实例 --&gt; &lt;bean id=\"myTestDIDao\" class=\"dao.TestDIDaoImpl\" /&gt; &lt;!-- 使用构造方法注入 --&gt; &lt;bean id=\"testDIService\" class=\"service.TestDIServiceImpl\"&gt; &lt;!-- 将myTestDIDao注入到TestDIServiceImpl类的属性testDIDao上 --&gt; &lt;constructor-arg index=\"0\" ref=\"myTestDIDao\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 创建test包 创建测试类TestDI，代码如下： 12345678910111213 package test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import service.TestDIService; public classs TestDI &#123; public static void main(String[] args) &#123; //初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext appCon = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //通过容器获取testDIService实例，测试构造方法注入 TestDIService ts = (TestDIService)appCon.getBean(\"testDIService\"); ts.sayHello(); &#125; &#125; 运行效果： ![image-20191122090138765](E:\\YihangJou\\Examples Demo（SSM+SpringBoot）\\A_Note\\Spring\\asset\\image-20191122090138765.png) 2.3.2 使用属性的setter方法注入​ 使用setter方法注入是Spring框架中最主流的注入方式，它利用Java Bean规范所定义的setter方法来完成注入，灵活且可读性高。对于setter方法注入，Spring框架也是使用Java的反射机制实现的。 实例讲解： 创建接口实现类TestDIServiceImpl 在service包中创建接口实现类TestDIServiceImpl1，在TestDIServiceImpl1中使用属性的setter方法依赖注入TestDIDao接口对象，代码如下： 123456789101112131415package service;import dao.TestDIDao;public class TestDIServiceImpl implements TestDIService &#123; private TestDIDao testDIDao; //添加testDIDao属性的setter方法，用于实现依赖注入 public void setTestDIDao(TestDIDao testDIDao) &#123; this.testDIDao = testDIDao; &#125; @Override public void sayHello() &#123; //调用testDIDao中的sayHello方法 testDIDao.sayHello(); System.out.println(\"TestDIService setter方法注入 say: Hello, Study hard!\"); &#125;&#125; 将TestDIServiceImpl1类托管给Spring 让Spring创建其对象，同时调用TestDISeriveImpl1类的setter方法完成依赖注入。代码如下： 12345&lt;!-- 使用setter方法注入 --&gt;&lt;bean id=\"testDIService1\" class=\"service.TestDIServiceImpl1\"&gt; &lt;!-- 调用TestDIServiceImpl1类的setter方法，将myTestDIDao注入到TestDIServiceImpl1类的属性testDIDao上 --&gt; &lt;property name=\"testDIDao\" ref=\"myTestDIDao\" /&gt;&lt;/bean&gt; 在test中测试setter方法注入 123//通过容器获取testDIService实例，测试setter方法注入TestDIService ts1=(TestDIService)appCon.getBean(\"testDIService1\");ts1.sayHello(); 运行效果： ![image-20191123233202956](E:\\YihangJou\\Examples Demo（SSM+SpringBoot）\\A_Note\\Spring\\asset\\image-20191123233202956.png)","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yihang.ml/categories/Spring/"}],"tags":[]},{"title":"5. Spring的事务管理","slug":"Spring/【Spring】5. Spring的事务管理","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:44:27.782Z","comments":true,"path":"2020/02/20/Spring/【Spring】5. Spring的事务管理/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Spring/%E3%80%90Spring%E3%80%915.%20Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","excerpt":"Spring的事务管理","text":"Spring的事务管理 5. Spring的事务管理5.1 Spring的数据库编程5.1.1 SpringJDBC的配置5.1.2 SpringJdbcTemplate的常用方法5.2 编程式事务管理5.2.1 基于底层API的编程式事务管理5.2.2 基于TransactionTemplate的编程式事物管理5.3 声明式事物管理5.3.1 基于XML方式的声明式事务管理5.3.2 基于@Transactional注解的声明式事务管理5.3.3 如何在事物管理中捕获异常","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yihang.ml/categories/Spring/"}],"tags":[]},{"title":"3. Spring Bean","slug":"Spring/【Spring】3. Spring Bean","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:43:25.300Z","comments":true,"path":"2020/02/20/Spring/【Spring】3. Spring Bean/","link":"","permalink":"https://www.yihang.ml/2020/02/20/Spring/%E3%80%90Spring%E3%80%913.%20Spring%20Bean/","excerpt":"Spring可以看作一个大型工厂，用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持XML和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。","text":"Spring可以看作一个大型工厂，用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持XML和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。 3. Spring Bean3.1 Bean的配置​ Spring可以看作一个大型工厂，用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持XML和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。 3.1.1 &lt;bean&gt;元素的常用属性及其子元素 3.1.2 Bean的配置实例代码12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 使用id属性定义myTestDIDao，其对应的实现类为dao.TestDIDaoImpl--&gt; &lt;bean id=\"myTestDIDao\" class=\"dao.TestDIDaoImpl\" /&gt; &lt;!-- 使用构造方法注入 --&gt; &lt;bean id=\"testDIService\" class=\"service.TestDIServiceImpl\"&gt; &lt;!-- 给构造方法传引用类型的参数值myTestDIDao --&gt; &lt;constructor-arg index=\"0\" ref=\"myTestDIDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3.2 Bean的实例化​ 在Spring框架中，如果想使用Spring容器中的Bean，需要实例化Bean。Spring框架实例化Bean有3种方式，即构造方法实例化、静态工厂实例化、和实例工厂实例化，其中最常见的是构造方法实例化。 3.2.1 构造方法实例化​ 在Spring框架中，Spring容器可以调用Bean对应类中的无参数构造方法来实例化Bean，这种方式称为构造方法实例化。 实例演示： 创建Web应用，在src目录下创建instance包，在包中创建BeanClass类 1234567891011package instance;public class BeanClass &#123; public String message; public BeanClass() &#123; message = \"构造方法实例化Bean\"; &#125; public BeanClass(String s) &#123; message = s; &#125;&#125; 创建配置文件 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- 构造方法实例化Bean--&gt; &lt;bean id=\"constructorInstance\" class=\"instance.BeanClass\" /&gt;&lt;/beans&gt; 创建测试类 12345678910111213141516package test;import instance.BeanClass;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestInstance &#123; public static void main(String[] args) &#123;// 初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext appCon = new ClassPathXmlApplicationContext(\"applicationContext.xml\");// 测试构造方法实例化Bean BeanClass b1 = (BeanClass) appCon.getBean(\"constructorInstance\"); System.out.println(b1+b1.message); &#125;&#125; 运行结果 3.2.2 静态工厂实例化​ 在使用静态工厂实例化Bean时要求开发者在工厂类中创建一个静态方法来创建Bean的实例。在配置Bean时，class属性指定静态工厂类，同时还需要使用factory-method属性指定工厂类中的静态方法。 实例演示： 创建工厂类BeanStaticFactory，在instance包中创建工厂类BeanStaticFactory 123456789package instance;public class BeanStaticFactory &#123; private static BeanClass beanInstance = new BeanClass(\"调用静态工厂方法实例化Bean\"); public static BeanClass createInstance() &#123; return beanInstance; &#125;&#125; 编辑配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- 静态工厂方法实例化Bean,createInstance为静态工厂类BeanStaticFactory中的静态方法--&gt; &lt;bean id=\"staticFactoryInstance\" class=\"instance.BeanStaticFactory\" factory-method=\"createInstance\" /&gt;&lt;/beans&gt; 添加测试代码 12345678910111213141516package test;import instance.BeanClass;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestInstance &#123; public static void main(String[] args) &#123;// 初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext appCon = new ClassPathXmlApplicationContext(\"applicationContext.xml\");// 测试静态工厂方法实例化Bean BeanClass b2 = (BeanClass) appCon.getBean(\"staticFactoryInstance\"); System.out.println(b2+b2.message); &#125;&#125; 运行效果 3.2.3 实例工厂实例化​ 在使用实例工厂实例化Bean时要求开发者在工厂类中创建一个实例方法来创建Bean的实例。在配置Bean时需要使用factory-method属性指定配置的实例工厂，同时还需要使用factory-method属性指定实例工厂中的实例方法。 创建工厂类BeanStaticFactory 在instance包中创建工厂类BeanInstanceFactory，该类中有一个实例方法类实例化对象 1234567package instance;public class BeanInstanceFactory &#123; public BeanClass createBeanClassInstance() &#123; return new BeanClass(\"调用实例工厂方法实例化Bean\"); &#125;&#125; 编辑配置文件 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- 配置工厂--&gt; &lt;bean id=\"myFactory\" class=\"instance.BeanInstanceFactory\" /&gt;&lt;!-- 使用factory-bean属性指定配置工厂，使用factory-method属性指定使用工厂中的哪个方法实例化Bean--&gt; &lt;bean id=\"instanceFactoryInstance\" factory-bean=\"myFactory\" factory-method=\"createBeanClassInstance\" /&gt;&lt;/beans&gt; 添加测试代码 12345678910111213141516package test;import instance.BeanClass;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestInstance &#123; public static void main(String[] args) &#123;// 初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext appCon = new ClassPathXmlApplicationContext(\"applicationContext.xml\");// 测试实例工厂方法实例化Bean BeanClass b3 = (BeanClass) appCon.getBean(\"instanceFactoryInstance\"); System.out.println(b3+b3.message); &#125;&#125; 运行效果 3.3 Bean的作用域3.3.1 在Spring 5.0中为Bean的实例定义的作用域 ​ singleton和prototype是最常用的两种，后面4中作用域尽在Web Spring应用程序上下文中使用。 3.3.2 singleton作用域​ 当bean的scope设置为singleton时，Spring IoC容器仅生成和管理一个Bean实例。在使用id或name获取Bean实例时，IoC容器将会返回共享的Bean实例。 ​ singleton时scope的默认方式，有两种方式将bean的scope设置为singleton。示例如下： 1&lt;bean id=\"constructorInstance\" class=\"instance.BeanClass\" /&gt; 或 1&lt;bean id=\"constructorInstance\" class=\"instance.BeanClass\" scope=\"singleton\"/&gt; ​ 在使用id或name获取Bean实例时，IoC容器仅返回同一个Bean实例。 3.3.3 prototype作用域​ 当bean的scope设置为prototype时，Spring IoC容器将为每次请求创建一个新的实例。示例如下： 1&lt;bean id=\"constructorInstance\" class=\"instance.BeanClass\" scope=\"prototype\"/&gt; 3.4 Bean的生命周期 Bean的生命周期过程： 步骤文字描述： Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化。 Bean实例化后对将Bean的引入和值注入到Bean的属性中。 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法。 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入。 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。 如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用 如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。 如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。 实例演示Bean的生命周期： 创建Bean的实现类 在src目录中创建life包，在life包下创建BeanLife类。在BeanLife类中有两个方法，一个演示初始化方法，一个演示销毁过程。 1234567891011package life;public class BeanLife &#123; public void initMyself() &#123; System.out.println(this.getClass().getName()+\"执行自定义的初始化方法\"); &#125; public void destoryMyself() &#123; System.out.println(this.getClass().getName()+\"执行自定义的销毁方法\"); &#125;&#125; 配置Bean 在Spring配置文件中使用实现类BeanLife配置一个id为beanLife的Bean。 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- 配置bean，使用iniit-method属性指定初始化方法，使用destroy-method属性指定销毁方法--&gt; &lt;bean id=\"beanLife\" class=\"life.BeanLife\" init-method=\"initMyself\" destroy-method=\"destoryMyself\" /&gt;&lt;/beans&gt; 测试声明周期 在test包中创建测试类TestLife。 1234567891011121314151617package test;import life.BeanLife;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestLife &#123; public static void main(String[] args) &#123;// 初始化Spring容器，加载配置文件// 为了方便演示销毁方法的执行，这里使用ClassPathXmlApplicationContext// 实现类声明容器 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); System.out.println(\"获得对象前\"); BeanLife blife = (BeanLife)ctx.getBean(\"beanLife\"); System.out.println(\"获得对象后\" + blife); ctx.close(); //关闭容器，销毁Bean对象 &#125;&#125; 运行效果 3.5 Bean的装配方式​ Bean的装配可以理解为将bean依赖注入到Spring容器中，Bean的装配方式即Bean依赖注入的方式。 3.5.1 基于XML配置的装配​ 在使用构造方法注入方式装配Bean时，Bean的实现类需要提供带参数的构造方法，并在配置文件中使用元素的子元素来定义构造方法的参数；在使用属性的setter方法注入方式装配Bean时，Bean的实现类需要提供一个默认无参数的构造方法，并为需要注入的属性提供对应的setter方法，另外还需要使用元素的子元素为每个属性注入值。 实例演示： 创建Bean的实现类 在src目录中创建assemble包，在assemble包下创建ComplexUser类。在ComplexUser类中分别使用构造方法注入和使用属性的setter方法注入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package assemble;import java.util.List;import java.util.Map;import java.util.Set;public class ComplexUser &#123; private String uname; private List&lt;String&gt; hobbyList; private Map&lt;String,String&gt; residenceMap; private Set&lt;String&gt; aliasSet; private String[] array; /* 使用构造方法注入，需要提供带参数的构造方法 */ public ComplexUser(String uname, List&lt;String&gt; hobbyList, Map&lt;String, String&gt; residenceMap, Set&lt;String&gt; aliasSet, String[] array) &#123; super(); this.uname = uname; this.hobbyList = hobbyList; this.residenceMap = residenceMap; this.aliasSet = aliasSet; this.array = array; &#125; /** * 使用属性的setter方法注入，提供默认无参数的构造方法，并为注入的属性提供setter方法 */ public ComplexUser() &#123; super(); &#125; @Override public String toString() &#123; return \"uname=\" + uname + \";hobbyList=\" + hobbyList + \";residenceMap=\" + residenceMap + \";aliasSet=\" + aliasSet +\";array=\" + array; &#125; // 此处为所有属性的setter方法 public void setUname(String uname) &#123; this.uname = uname; &#125; public void setHobbyList(List hobbyList) &#123; this.hobbyList = hobbyList; &#125; public void setResidenceMap(Map residenceMap) &#123; this.residenceMap = residenceMap; &#125; public void setAliasSet(Set aliasSet) &#123; this.aliasSet = aliasSet; &#125; public void setArray(String[] array) &#123; this.array = array; &#125;&#125; 配置Bean 在Spring配置文件中使用实现类ComplexUser配置Bean的两个实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- 使用构造方法注入方式装配ComplexUser实例user1--&gt; &lt;bean id=\"user1\" class=\"assemble.ComplexUser\"&gt; &lt;constructor-arg index=\"0\" value=\"yihang1\" /&gt; &lt;constructor-arg index=\"1\"&gt; &lt;list&gt; &lt;value&gt;唱歌&lt;/value&gt; &lt;value&gt;跳舞&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=\"2\"&gt; &lt;map&gt; &lt;entry key=\"dalian\" value=\"大连\" /&gt; &lt;entry key=\"beijing\" value=\"北京\" /&gt; &lt;entry key=\"shanghai\" value=\"上海\" /&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=\"3\"&gt; &lt;set&gt; &lt;value&gt;逸航01&lt;/value&gt; &lt;value&gt;逸航02&lt;/value&gt; &lt;value&gt;逸航03&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=\"4\"&gt; &lt;array&gt; &lt;value&gt;aaaaa&lt;/value&gt; &lt;value&gt;bbbbb&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;!-- 使用属性的setter方法注入方式装配 ComplexUser实例user2--&gt; &lt;bean id=\"user2\" class=\"assemble.ComplexUser\"&gt; &lt;property name=\"uname\" value=\"yihang2\" /&gt; &lt;property name=\"hobbyList\"&gt; &lt;list&gt; &lt;value&gt;看书&lt;/value&gt; &lt;value&gt;学习Spring&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"residenceMap\" &gt; &lt;map&gt; &lt;entry key=\"shenzhen\" value=\"深圳\" /&gt; &lt;entry key=\"guangzhou\" value=\"广州\" /&gt; &lt;entry key=\"tianjin\" value=\"天津\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"aliasSet\"&gt; &lt;set&gt; &lt;value&gt;逸航04&lt;/value&gt; &lt;value&gt;逸航05&lt;/value&gt; &lt;value&gt;逸航06&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"array\"&gt; &lt;array&gt; &lt;value&gt;ccccc&lt;/value&gt; &lt;value&gt;ddddd&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试基于XML配置的装配方式 在test包中创建测试类TestAssemble。 123456789101112131415161718package test;import assemble.ComplexUser;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAssemble &#123; public static void main(String[] args) &#123; ApplicationContext appCon = new ClassPathXmlApplicationContext(\"applicationContext.xml\");// 使用构造方法装配测试 ComplexUser u1 = (ComplexUser) appCon.getBean(\"user1\"); System.out.println(u1); System.out.println(\"-------------------------\");// 使用setter方法装配测试 ComplexUser u2 = (ComplexUser) appCon.getBean(\"user2\"); System.out.println(u2); &#125;&#125; 运行效果 3.5.2 基于注解的装配​ 大量的Bean装配会导致XML配置文件过于庞大，不方便以后的升级与维护，因此更多的时候推荐开发者使用注解（annotation）的方式去装配Bean。 3.5.1.1 @Component​ 该注解是一个泛化的概念，仅仅表示一个组件对象（Bean），可以作用在任何层次上。 3.5.2.2 @Repository​ 该注解用于将数据访问层（DAO）的类标识为Bean，即注解数据访问层Bean，其功能与@Component相同。 3.5.2.3 @Service​ 该注解用于标注一个业务逻辑组件类（Service层），其功能与@Component相同。 3.5.2.4 @Controller​ 该注解用于标注一个控制器组件类（Spring MVC的Controller），其功能与@Component相同。 3.5.2.5 @Autowired​ 该注解可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作。通过使用@Autowired来消除setter和getter方法。默认按照Bean的类型进行装配。 3.5.2.6 @Resource​ 该注解与@Autowired的功能一样，区别在于该注解默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean时才会按照类型来装配注入；而@Autowired默认按照Bean的类型进行装配，如果想按照名称来装配注入，则需要和@Qualifier注解一起使用。 3.5.3.7 @Qualifier​ 该注解与@Aitowired注解配合使用。当@Autowired注解需要按照名称来装配注入时需要和该注解一起使用，Bean的实例名称由@Qualifier注解的参数制定。 实例演示： 创建DAO层 在src中创建annotation.dao包，在该包下创建TestDao接口和TestDaoImpl实现类，并将实现类TestDaoImpl使用@Repository注解标注为数据访问层。 TestDao的代码如下： 12345package annotation.dao;public interface TestDao &#123; public void save();&#125; TestDaoImpl的代码如下： 123456789101112131415package annotation.dao;import org.springframework.stereotype.Repository;@Repository(\"testDao\")/** * 相当于@Repository，但如果在service层中使用@Resource(name=\"testDao\"), * testDao不能省略 */public class TestDaoImpl implements TestDao &#123; @Override public void save() &#123; System.out.println(\"testDao save\"); &#125;&#125; 创建Service层 在src中创建annotation.service包，在该包下创建TestService接口和TestServiceImpl实现类，并将实现类TestServiceImpl使用@service注解标注为业务逻辑层。 Testservice的代码如下： 12345package annotation.service;public interface TestService &#123; public void save();&#125; TestServiceImpl的代码如下： 12345678910111213141516171819package annotation.service;import annotation.dao.TestDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Service(\"testService\") //相当于@Servicepublic class TestSerivceImpl implements TestService &#123;// @Resource(name=\"testDao\") @Autowired// 相当于@Autowired，@Autowired默认按照Bean状态装配 private TestDao testDao; @Override public void save() &#123; testDao.save(); System.out.println(\"testService save\"); &#125;&#125; 创建Controller层 在src中创建annotation.controller包，在该包下创建TestController类，并将TestController类使用@Controller注解标注为控制器层。 TestController的代码如下： 12345678910111213141516package annotation.controller;import annotation.service.TestService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class TestController &#123; @Autowired private TestService testService; public void save() &#123; testService.save(); System.out.println(\"testController save\"); &#125;&#125; 配置注解 由于annotation.dao、annotation.service和annotation.controller包都属于annotation包的子包，因此不要在配置文件annotationContext.xml中配置注解。 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"annotation\" /&gt;&lt;/beans&gt; 创建测试类 12345678910111213package test;import annotation.controller.TestController;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestMoreAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext appCon = new ClassPathXmlApplicationContext(\"annotationContext.xml\"); TestController testcon = (TestController) appCon.getBean(\"testController\"); testcon.save(); &#125;&#125; 运行效果","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.yihang.ml/categories/Spring/"}],"tags":[]},{"title":"物料生产管理系统","slug":"项目/物料生产管理系统","date":"2020-02-20T04:12:57.000Z","updated":"2020-05-29T13:45:42.927Z","comments":true,"path":"2020/02/20/项目/物料生产管理系统/","link":"","permalink":"https://www.yihang.ml/2020/02/20/%E9%A1%B9%E7%9B%AE/%E7%89%A9%E6%96%99%E7%94%9F%E4%BA%A7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"基于物料的生产管理系统具备物料采购，仓储，产成品管理以及成品审核等多种功能。","text":"基于物料的生产管理系统具备物料采购，仓储，产成品管理以及成品审核等多种功能。 物料生产管理系统1. 技术栈（1）后端 Spring Boot MySQL Spring Securtiy Redis （2）前端 Vue.js Element-UI eCharts 2. 界面设计","categories":[{"name":"项目","slug":"项目","permalink":"https://www.yihang.ml/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.yihang.ml/categories/Linux/"},{"name":"Git","slug":"Git","permalink":"https://www.yihang.ml/categories/Git/"},{"name":"Servlet、Jsp","slug":"Servlet、Jsp","permalink":"https://www.yihang.ml/categories/Servlet%E3%80%81Jsp/"},{"name":"Spring","slug":"Spring","permalink":"https://www.yihang.ml/categories/Spring/"},{"name":"项目","slug":"项目","permalink":"https://www.yihang.ml/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[]}